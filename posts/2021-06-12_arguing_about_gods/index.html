<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Austin Hoover">
<meta name="dcterms.date" content="2021-06-12">

<title>Accelerated Inquiry - Arguing about gods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Accelerated Inquiry</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about/index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Arguing about gods</h1>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Austin Hoover </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 12, 2021</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>I’m reading the book <em>Arguing About Gods</em> by Graham Oppy, one of the most prominent philosophers of religion <span class="citation" data-cites="Oppy2006-gods">&nbsp;[<a href="#ref-Oppy2006-gods" role="doc-biblioref">1</a>]</span>. Oppy’s main thesis is that there are no successful arguments for the existence of orthodoxly conceived monotheistic gods, where “orthodoxly conceived monotheistic god” refers to an omnipotent, omniscient, omnibenevolent creator of the world — I’ll take “God” to mean the same thing — and “successful arguments” will be defined later. The book is organized as follows:</p>
<ol type="1">
<li>Preliminary Considerations</li>
<li>Ontological Arguments</li>
<li>Cosmological Arguments</li>
<li>Teleological Arguments</li>
<li>Pascal’s Wager</li>
<li>Arguments from Evil</li>
<li>Other Arguments</li>
<li>Concluding Remarks</li>
</ol>
<p>I’m planning to write a post for each of these chapters. In each post, I’ll try to summarize Oppy’s ideas, discuss known challenges to these ideas if I’m aware of them, and record my thoughts and/or questions as they arise.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> This post will focus on the first chapter.</p>
<p>Before I begin, I should mention what I hope to achieve during this study. My general goal is to think more carefully about each of the following questions (<em>G</em> stands for the question of the existence of God):</p>
<ul>
<li>How, and on what basis, do I answer <em>G</em>?</li>
<li>How confident am I in my answer to <em>G</em>?</li>
<li>Could my answer to <em>G</em> change in the future?</li>
<li>What is the relationship between my answer to <em>G</em> and my other beliefs?</li>
<li>Do I — or should I — treat <em>G</em> in the same way as I treat other questions? Why or why not?</li>
<li>How should I understand disagreement about <em>G</em> between equally intelligent people?</li>
<li>What role should internal evidence — intuitions, feelings, things I just take to be true — play when forming an answer to <em>G</em>?</li>
</ul>
<p>I’ll briefly give my current thinking on “How confident am I in my answer to <em>G</em>?”. A helpful concept discussed in the book and many other places is that of credence: my credence <em>x</em> in a proposition <em>S</em> is a value ranging from 0 to 1 which represents how confident I am that <em>S</em>. This contrasts with the three traditional responses: belief, disbelief, or withheld judgment. But perhaps it’s too difficult to choose a specific value for <em>x</em>; maybe it’s better to choose a credence interval <em>r</em> = (<em>p</em>, <em>q</em>) such that <em>x</em> is somewhere within this interval; perhaps <em>r</em> = (0.9, 1) if I’m very confident, <em>r</em> = (0, 0.1) if I’m not very confident, etc.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> It’s also still possible to choose a zero-width interval like <em>r</em> = (0.33, 0.33). If <em>S</em> = “God exists”, then the atheist’s credence interval may be bounded by (0, 0.5), the theist’s by (0.5, 1), and the agnostic’s by (0.5, 0.5).</p>
<p>My inclination is to make <em>r</em> quite narrow and centered on 0.5; I don’t think this is a good or bad thing — it’s just how my brain works. I’d be tempted to call this agnosticism. My actual credence interval, however, might be something like (0.45, 0.65). I’m attracted by several arguments for theism, but also by a couple of arguments for atheism. Overall, I’m more convinced by arguments for theism than for atheism, hence the higher upper bound. There are also other issues at play, but that’s the short explanation for my choice.</p>
<p>It’s hard to know if the numbers I chose are accurate.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> I mean “accurate” in the following sense: maybe I would choose an interval with a different width or mean if a gun was held to my head or if I thought about the question in more depth. I’ll hopefully have an improved credence interval by the end of this study. This may sound strange: why not change my interval if I don’t think it’s accurate? Part of the reason is that I’ve only recently begun to consider credence and belief as distinct, so I’d like to think more about how I’m choosing my interval. For example, what is my credence interval for the proposition “I won’t die at an early age”, and how does this relate to my belief that I won’t die at an early age? I’m also expecting my interval to shift as I think more about <em>G</em>.</p>
<p>I’ll now move on to summarizing and commenting on the four sections of this first chapter.</p>
</section>
<section id="arguments-about-the-existence-of-monotheistic-gods" class="level2">
<h2 class="anchored" data-anchor-id="arguments-about-the-existence-of-monotheistic-gods">Arguments about the existence of monotheistic gods</h2>
<p>This section explains how the various arguments for and against the existence of God have been organized in the book. First, ontological arguments appeal to reason alone. Second, cosmological arguments appeal to necessary features of the world. Third, teleological arguments appeal to contingent features of the world. Fourth, moral arguments appeal to the moral structure of the world. Fifth, arguments such as Pascal’s wager simply claim that belief in God is rational. Sixth, there are also “minor” arguments such as the argument from consciousness or the argument from beauty. Finally, there are arguments from personal religious experience, corporate religious experience, etc.</p>
<p>An interesting point is made about cumulative arguments. If there is a set of <em>n</em> arguments, all with the same conclusion, is the entire set stronger than any of the individual members? Not necessarily. For example, all the arguments could be strong except for one, which is circular; in this case, a mega-argument formed from all the arguments in the set would also be circular and hence weaker than any of the strong arguments in isolation. The mega-argument could be stronger than any individual argument if the arguments are viewed probabilistically, i.e., each argument uses some evidence to raise or lower the probability of its conclusion. Oppy doesn’t like this idea; he notes that each argument only considers a carefully selected portion of the full body of evidence and that the correct thing to do is to consider all the evidence at once. Discussion is left for later chapters.</p>
<p>Alexander Pruss raises the following problems with this treatment of cumulative arguments in his <a href="https://ndpr.nd.edu/reviews/arguing-about-gods/">review</a>. Suppose each argument has one premise that could be rejected by a reasonable person who holds a particular view —a moral realist will reject this premise, a materialist will reject that premise, etc. But unless each premise could be rejected on the same grounds, it doesn’t follow that a single person could hold all these views at the same time without contradictions. Pruss is also critical of Oppy’s suggestion that all the evidence must be considered at the same time if arguments are viewed probabilistically; instead, only the evidence relevant to a given statement is required to evaluate that statement. I’m keen to align with Pruss here.</p>
</section>
<section id="arguments" class="level2">
<h2 class="anchored" data-anchor-id="arguments">Arguments</h2>
<p>This section discusses what makes arguments successful. Oppy says this requires “(1) an account of rationality and rational belief revision, (2) an account of arguments, (3) an account of rational argumentation amongst rational agents, and (4) an account of the difficulties that arise as a result of the fact that we are not perfectly rational agents”.</p>
<p>It’s claimed that it’s possible for two perfectly rational people to disagree even if they have access to the same evidence. This seems wrong at first. The reasoning is: 1) the order in which the evidence is processed might be important, 2) there is a limit to how much information can be stored in a person’s mind at one time, and further 3) it could be argued that we generally make decisions in a Bayesian sense, evaluating the probability of the evidence given a set of prior probabilities or prior beliefs. In this way, every new belief is formed against the background of other beliefs. If this is true of perfectly rational people, then, of course, we can expect disagreement between less-than-perfectly rational people.</p>
<p>It’s also claimed that the point of arguments is to cause reasonable belief revision.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> The following definition of a successful argument is given:</p>
<blockquote class="blockquote">
<p>The most successful argument would be one that succeeds — or perhaps would or ought to succeed — in persuading any reasonable person to accept its conclusion; good, but less successful arguments would succeed — or perhaps would or ought to succeed — in persuading a non-zero percentage of reasonable people to accept their conclusions.</p>
</blockquote>
<p>Thus, successful arguments are extremely difficult to form. Imagine I’m trying to change Alice’s mind. I should form an argument whose conclusion follows from premises Alice already believes; I’ll otherwise need to convince Alice of the premises using separate arguments. There’s nothing inherently wrong with this, but we may eventually reach beliefs for which there are no appeals to other beliefs for justification, and there is no hope of changing Alice’s mind if we disagree about those, at least not using arguments. If this view is correct, then arguments might not be the best way to persuade other reasonable people.</p>
<p>That it’s difficult to change the mind of a reasonable person is further supported by observing myself. I remember having long (friendly, non-serious) debates with my friends in college about various topics. I recall that, in some of these discussions, I didn’t even have a strong opinion on the topic beforehand. Yet, it was quite difficult to change the belief I formed at the beginning of the debate. I would think: “I formed this belief five minutes ago based on my intuition, and my intuition is infallible!” In hindsight, I was wrong some of the time and my arguments were likely weak. The fact that I had a strong resistance to changing my beliefs, even though I had very little to lose by giving them up, demonstrates that it would be difficult to change my mind about my core beliefs using arguments alone.</p>
<p>There are some questions about this view of successful arguments. Notice the phrase “would or ought to succeed”. Suppose there’s a premise <em>h</em> that any reasonable person would or ought to accept. I take “would” to mean that Austin would accept <em>h</em> if he had a certain set of priors and if his reasoning faculties were functioning correctly, and I take “ought” to mean that Austin ought to accept <em>h</em> since he has a certain set of priors and since his reasoning faculties are functioning correctly. One question is whether there are constraints on a reasonable person’s priors. On this, Oppy writes:</p>
<blockquote class="blockquote">
<p>I am not committing myself to the claim that there are no substantive constraints on ‘priors’ — it may be that there are quite severe constraints on reasonable sets of ‘priors’; however, I am claiming that I can see no reason at all for thinking that there is a unique set of ‘priors’ that any reasonable person must have on pain of conviction of irrationality.</p>
</blockquote>
<p>How can we know that Austin’s priors obey these constraints? Pruss has some things to say about a related issue in the beginning of his review.</p>
<p>I also want to mention a potential problem for theists who accept that there can be disagreement about God between reasonable truth-seeking people. This is the problem of divine hiddenness: it seems plausible that God would guide all reasonable truth-seekers to true beliefs about God if God existed, but there are reasonable truth-seekers who don’t believe in God. Perhaps this will come up in future chapters.</p>
</section>
<section id="some-considerations-about-agnosticism" class="level2">
<h2 class="anchored" data-anchor-id="some-considerations-about-agnosticism">Some considerations about agnosticism</h2>
<p>In this section, Oppy distinguishes between weak agnosticism and strong agnosticism. He then argues that strong agnosticism fails, but that weak agnosticism is acceptable. The strong agnostic’s view can be summarized as:</p>
<ol type="1">
<li>In circumstances in which the available evidence no more — and no less — supports <span class="math inline">\(p\)</span> than it supports logically incompatible hypotheses <span class="math inline">\(p_1\)</span>, <span class="math inline">\(\dots\)</span>, <span class="math inline">\(p_n\)</span>, <span class="math inline">\(\dots\)</span>, one ought to suspend judgment between <span class="math inline">\(p\)</span>, <span class="math inline">\(p_1\)</span>, <span class="math inline">\(\dots\)</span>, <span class="math inline">\(p_n\)</span>, <span class="math inline">\(\dots\)</span> as well as the hypothesis that <span class="math inline">\(p\)</span> is false.</li>
<li>There are infinitely many God hypotheses, none of which are more likely than the others given the available evidence (e.g., a god who is not quite omniscient, a god who is not quite omnipotent, two gods rather than one, etc.).</li>
<li>It is neither rational to believe that God exists, nor to believe that God does not exist.</li>
</ol>
<p>Let’s start with (1). It wasn’t obvious to me why we shouldn’t think that <em>p</em> is false in this case. There is, however, a paradox that might illustrate the reason. Consider a lottery with infinitely many tickets. I shouldn’t believe that my ticket is the winner since the probability is infinitesimal.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> But I should think this about each ticket, which amounts to believing that <em>no</em> ticket is the winner — a false belief. So, I should neither believe nor disbelieve that any particular ticket is the winner (that God exists).</p>
<p>So, (1) seems to make sense; however, there is a major problem: believing (1) could make it very difficult to avoid skepticism about basic things like the reality of my perceived world. Consider my belief that I am not a brain in a vat (BIV). On what basis do I believe this? My belief can’t be based on external evidence because the BIV hypothesis explains this evidence just as well as the alternative. Rather, it must be due to some internal evidence; in other words, the belief is basic.</p>
<p>If I accept that some beliefs are basic and accept the principle that it’s best to keep a belief unless there is some good reason to give it up (Oppy calls this “methodological conservatism”), then I have good reason to believe I’m not a BIV. The strong agnostic doesn’t agree with this and seems forced to suspend judgment on whether they are a BIV. The same would go for the belief that I didn’t pop into existence two seconds ago, and so on.</p>
<p>The strong agnostic needs to make some distinction between the God hypotheses and the cases involving extreme skepticism; however, there’s no clear way to do this. Oppy notes that the best approach is probably to say that my skepticism about the external world requires me to believe I’m special — somehow, I’m the only real thing in my perceived world — and that this gives me a reason to reject my skepticism. Call this the “I’m special” consideration ISC. However, Oppy proceeds, if the strong atheist concedes that the ISC is required to distinguish between these cases, then they have conceded that external evidence is not the only thing that can support reasonable beliefs, for the reason why the ISC should count against the truth of a belief is not clear from external evidence even though it may be clear to the strong agnostic. So, the problem is not that the strong agnostic is unreasonable for liking the ISC, it’s that they might be forced to choose between extreme skepticism and admitting that theists and atheists can be reasonable. In other words, the strong agnostic cannot believe (3) and the following statement at the same time:</p>
<ol start="4">
<li>
It is possible to characterize a suitable notion of evidential support that does not rely upon a relativization to background assumptions.
</li>
</ol>
<p>This last view — suspending belief or non-belief in God while recognizing that this is not the only reasonable way to proceed — is weak agnosticism.</p>
</section>
<section id="alternative-deities" class="level2">
<h2 class="anchored" data-anchor-id="alternative-deities">Alternative deities</h2>
<p>The final section of this chapter considers the arguments for alternative deities like God*. God* is exactly like God but is completely evil. The thought is that the arguments for God work just as well for God*. For example, one way to respond to the problem of evil is to adopt skeptical theism, and it seems that this view could also be used as a defense of God*.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> Any arguments for which this applies would then seem to be ineffective as attacks against non-theists. A further step would be to claim that there is no way to choose God over God* and that theists should therefore give up their belief in God.</p>
<p>If one thinks that moral facts exist and can be known, which I think I do, then the following critique will be convincing. An omniscient being would know all moral facts, but it’s impossible to believe that an action is wrong without being inclined to refrain from performing that action, i.e., I couldn’t know that murder is wrong but have no problem carrying out murder myself. Therefore, God* is logically impossible.</p>
<p>If God* is off the table, then God’ could be introduced. God’ is as close to God* as possible: completely evil, but not quite omniscient. Again, the arguments for God seem to work for God’. If the idea of God’ is shown to be incoherent, maybe we could think of God’’, God’’’, God#, etc. Oppy thinks these alternative deities could be useful to the non-theist as a defense, but not as an attack. This is because the theist likely has a set of prior beliefs that make an orthodoxly conceived monotheistic god seem the most likely to them even if they accept that some arguments don’t nail down God’s moral character. In general, it’s supposed that we shouldn’t be forced to give up a belief just because we recognize the existence of alternatives that seem just as good to an outside observer.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This chapter was primarily about epistemology. I haven’t thought much about this topic — almost not at all before recently reading Alvin Plantinga’s <em>Knowledge and Christian Belief</em> — and I think that articulating my epistemological views is necessary to answer the questions I listed at the beginning of this post. A good first step might be to read the relevant entry in the <a href="https://plato.stanford.edu/entries/epistemology/">Stanford Encyclopedia of Philosophy</a>.</p>
<p>I’m looking forward to the remaining chapters in the book in which specific arguments for the existence of God are examined.</p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-Oppy2006-gods" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">G. Oppy, <em>Arguing about Gods</em> (Cambridge University Press, 2006).</div>
</div>
<div id="ref-Jackson2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">E. G. Jackson, <em>The Relationship Between Belief and Credence</em>, Philosophy Compass <strong>15</strong>, e12668 (2020).</div>
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>I won’t use direct quotes very often; hopefully it’s clear when I’m paraphrasing the book vs.&nbsp;discussing the book.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I probably shouldn’t choose [0, <em>q</em>) or (<em>p</em>, 1]; in this case, I would possibly think there is <em>zero</em> chance that <em>S</em> is true (or false).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Some argue that credences don’t exist in reality; see<span class="citation" data-cites="Jackson2020">&nbsp;[<a href="#ref-Jackson2020" role="doc-biblioref">2</a>]</span>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Oppy switches from “rational” to “reasonable”, and I’m sometimes confused by the difference.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>An infinitesimal is smaller than every number but greater than zero.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Skeptical theism is the view that we’re not in a position to know God’s thoughts, motives, etc. in any specific situation.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/austin-hoover\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="austin-hoover/austin-hoover.github.io/blog" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>