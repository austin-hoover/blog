<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Austin Hoover">
<meta name="dcterms.date" content="2021-10-16">

<title>Austin’s Blog - Tomographic reconstruction in four dimensions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-DLC4C8LZFB"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-DLC4C8LZFB', { 'anonymize_ip': true});
</script>
<script type="application/json" class="js-hypothesis-config">
{
  "theme": "clean",
  "openSidebar": false
}
</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Austin’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about/index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../links.html"> 
<span class="menu-text">Links</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#d-reconstruction" id="toc-d-reconstruction" class="nav-link" data-scroll-target="#d-reconstruction">2D reconstruction</a>
  <ul>
  <li><a href="#filtered-back-projection-fpb" id="toc-filtered-back-projection-fpb" class="nav-link" data-scroll-target="#filtered-back-projection-fpb">Filtered Back-Projection (FPB)</a></li>
  <li><a href="#algebraic-reconstruction-art" id="toc-algebraic-reconstruction-art" class="nav-link" data-scroll-target="#algebraic-reconstruction-art">Algebraic Reconstruction (ART)</a></li>
  <li><a href="#ment" id="toc-ment" class="nav-link" data-scroll-target="#ment">MENT</a></li>
  <li><a href="#grid-based-methods" id="toc-grid-based-methods" class="nav-link" data-scroll-target="#grid-based-methods">Grid-based methods</a></li>
  </ul></li>
  <li><a href="#d-reconstruction-1" id="toc-d-reconstruction-1" class="nav-link" data-scroll-target="#d-reconstruction-1">4D reconstruction</a>
  <ul>
  <li><a href="#description-of-hocks-method" id="toc-description-of-hocks-method" class="nav-link" data-scroll-target="#description-of-hocks-method">Description of Hock’s method</a></li>
  <li><a href="#accuracy" id="toc-accuracy" class="nav-link" data-scroll-target="#accuracy">Accuracy</a></li>
  </ul></li>
  <li><a href="#feasibility" id="toc-feasibility" class="nav-link" data-scroll-target="#feasibility">Feasibility</a>
  <ul>
  <li><a href="#imaging-system" id="toc-imaging-system" class="nav-link" data-scroll-target="#imaging-system">Imaging system</a></li>
  <li><a href="#optics-control" id="toc-optics-control" class="nav-link" data-scroll-target="#optics-control">Optics control</a></li>
  <li><a href="#outlook" id="toc-outlook" class="nav-link" data-scroll-target="#outlook">Outlook</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Tomographic reconstruction in four dimensions</h1>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Austin Hoover </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 16, 2021</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>A beam of particles in an accelerator is characterized by its distribution in phase space — the space of positions <span class="math inline">\(\{x, y, z\}\)</span> and momenta <span class="math inline">\(\{x', y', z'\}\)</span>. I’m currently working on a project in which we’d like to measure the four-dimensional (4D) phase space distribution <span class="math inline">\(f(x, x', y, y')\)</span> of a fully-accumulated beam in the Spallation Neutron Source (SNS).</p>
<p>A direct way to do this is to use a series of slits to block all particles outside a small region <span class="math inline">\(\mathbf{x} \pm \Delta\mathbf{x}\)</span>, where <span class="math inline">\(\mathbf{x} = (x, x', y, y')\)</span>, and move <span class="math inline">\(\mathbf{x}\)</span> through phase space. This method is accurate but slow and not available for our beam (<span class="math inline">\(10^{14}\)</span> protons moving at 90% the speed of light). The best we can do is to measure projections of the distribution; i.e., lower-dimensional views such as</p>
<p><span class="math display">\[
f(x) = \int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}{f(x, x', y, y') dx' dy dy'}
\]</span></p>
<p>and estimate the distribution from these projections. This is called <em>tomographic reconstruction</em>.</p>
<p>Tomographic reconstruction is used in a wide variety of fields, particularly in medical imaging where X-rays are used to generate 1D projections of a 2D slice of organic material at various angles. The same idea can be applied to a phase space distribution. Consider <span class="math inline">\(f(x, x')\)</span>. It’s straightforward to measure a 1D projection along the <span class="math inline">\(x\)</span> axis by sweeping a vertical conducting wire across the beam path; the problem is that this only corresponds to one projection angle. The trick is to approximate motion in an accelerator as a series of linear transformations of the phase space coordinates: shearing, scaling, and rotation. Thus, the projection of a beam at one location onto the <span class="math inline">\(x\)</span> axis is a scaled projection of a projection onto a rotated axis at a different location. The projection angle can be controlled by varying the electromagnetic fields between the two locations.</p>
<p>It’s more challenging to find <span class="math inline">\(f(x, x', y, y')\)</span>. It’s simple to reconstruct the <span class="math inline">\(4 \times 4\)</span> covariance matrix from 1D projections; I’ve implemented this method in the SNS and won’t discuss it here. To obtain the 4D <em>distribution</em>, we generally need at least 2D projections. I’m interested in this approach because the final destination of the SNS beam — the target&nbsp;— is coated with a luminescent material which gives the 2D projection onto the <span class="math inline">\(x\)</span>-<span class="math inline">\(y\)</span> plane. The idea that I’ll begin to explore in this post is whether these 2D projections can be used to reconstruct the 4D phase space distribution. I’ll first go over the common reconstruction algorithms in 2D and mention if they could be extended to 4D.</p>
</section>
<section id="d-reconstruction" class="level2">
<h2 class="anchored" data-anchor-id="d-reconstruction">2D reconstruction</h2>
<div id="2516723f-a02b-46f5-a271-4d984dd368a1" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> proplot <span class="im">as</span> pplt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage <span class="im">import</span> transform</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> psdist.visualization <span class="im">as</span> psv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>I’ll use the following distribution to test the reconstruction algorithms.</p>
<div id="dcd32160-3f7f-4250-aa07-f64451225d8c" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fl">1.75</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">300000</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.vstack([</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    np.random.normal(scale<span class="op">=</span>[<span class="fl">1.0</span>, <span class="fl">1.0</span>], loc<span class="op">=</span>[<span class="fl">0.0</span>, <span class="fl">0.0</span>], size<span class="op">=</span>(n, <span class="dv">2</span>)),</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    np.random.normal(scale<span class="op">=</span><span class="fl">0.6</span>, loc<span class="op">=</span>[<span class="op">+</span>a, <span class="op">+</span>a], size<span class="op">=</span>(n<span class="op">//</span><span class="dv">5</span>, <span class="dv">2</span>)),</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    np.random.normal(scale<span class="op">=</span><span class="fl">0.6</span>, loc<span class="op">=</span>[<span class="op">+</span>a, <span class="op">-</span>a], size<span class="op">=</span>(n<span class="op">//</span><span class="dv">5</span>, <span class="dv">2</span>)),</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    np.random.normal(scale<span class="op">=</span><span class="fl">0.6</span>, loc<span class="op">=</span>[<span class="op">-</span>a, <span class="op">+</span>a], size<span class="op">=</span>(n<span class="op">//</span><span class="dv">5</span>, <span class="dv">2</span>)),</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    np.random.normal(scale<span class="op">=</span><span class="fl">0.6</span>, loc<span class="op">=</span>[<span class="op">-</span>a, <span class="op">-</span>a], size<span class="op">=</span>(n<span class="op">//</span><span class="dv">5</span>, <span class="dv">2</span>)),</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>n_bins <span class="op">=</span> <span class="dv">60</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>xmax <span class="op">=</span> <span class="fl">5.0</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>limits <span class="op">=</span> [(<span class="op">-</span>xmax, xmax), (<span class="op">-</span>xmax, xmax)]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>Z_true, xedges, yedges <span class="op">=</span> np.histogram2d(X[:, <span class="dv">0</span>], X[:, <span class="dv">1</span>], n_bins, limits, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>xcenters <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> (xedges[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> xedges[<span class="dv">1</span>:])</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>ycenters <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> (yedges[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> yedges[<span class="dv">1</span>:])</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> pplt.subplots()</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>ax.pcolormesh(xcenters, ycenters, Z_true.T)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">format</span>(xlabel<span class="op">=</span><span class="st">"x"</span>, ylabel<span class="op">=</span><span class="st">"x'"</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_dist2d.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="_output_dist2d.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></a></p>
</figure>
</div>
<p>We now simulate the measurements. Assume we have the ability to rotate the distribution without any shearing or scaling. We then rotate the distribution by different angles and project it onto the <span class="math inline">\(x\)</span> axis. It will turn out that measurement time limits the number of projections we can use; for now, we’ll limit ourselves to 15 projections.</p>
<div id="0f110dd4-d299-4133-82fd-caaa17f8de99" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rotation_matrix(angle):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    cs, sn <span class="op">=</span> np.cos(angle), np.sin(angle)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([[cs, sn], [<span class="op">-</span>sn, cs]])</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>n_proj <span class="op">=</span> <span class="dv">15</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">180.0</span>, n_proj, endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>transfer_matrices <span class="op">=</span> [rotation_matrix(np.radians(angle)) <span class="cf">for</span> angle <span class="kw">in</span> angles]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>projections <span class="op">=</span> np.zeros((n_bins, n_proj))</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_proj):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> transfer_matrices[k]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    X_meas <span class="op">=</span> np.apply_along_axis(<span class="kw">lambda</span> row: np.matmul(M, row), <span class="dv">1</span>, X)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    projections[:, k], _ <span class="op">=</span> np.histogram(X_meas[:, <span class="dv">0</span>], n_bins, limits[<span class="dv">0</span>], density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> pplt.subplots()</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>ax.pcolormesh(projections.T)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">format</span>(xlabel<span class="op">=</span><span class="st">"Projection axis"</span>, ylabel<span class="op">=</span><span class="st">"Projection number"</span>, ytickminor<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_sinogram.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="_output_sinogram.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></a></p>
</figure>
</div>
<p>We’ll also need some helper functions.</p>
<div id="e6628ff4-6b44-41cd-b372-12b888c4f6d5" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="bu">apply</span>(M, X):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.apply_along_axis(<span class="kw">lambda</span> row: np.matmul(M, row), <span class="dv">1</span>, X)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> project(Z, indices):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(indices) <span class="kw">is</span> <span class="bu">int</span>:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> [indices]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    axis <span class="op">=</span> <span class="bu">tuple</span>([k <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>) <span class="cf">if</span> k <span class="kw">not</span> <span class="kw">in</span> indices])</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(Z, axis<span class="op">=</span>axis)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> normalize(Z, bin_volume<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> np.<span class="bu">sum</span>(Z)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count <span class="op">==</span> <span class="fl">0.0</span>:</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Z</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Z <span class="op">/</span> count <span class="op">/</span> bin_volume</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_bin_volume(limits, n_bins):</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(n_bins) <span class="kw">is</span> <span class="bu">int</span>:</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        n_bins <span class="op">=</span> <span class="bu">len</span>(limits) <span class="op">*</span> [n_bins]</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.prod([((lim[<span class="dv">1</span>] <span class="op">-</span> lim[<span class="dv">0</span>]) <span class="op">/</span> n) <span class="cf">for</span> lim, n <span class="kw">in</span> <span class="bu">zip</span>(limits, n_bins)])</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process(Z, keep_positive<span class="op">=</span><span class="va">False</span>, density<span class="op">=</span><span class="va">False</span>, limits<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> keep_positive:</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        Z <span class="op">=</span> np.clip(Z, <span class="fl">0.0</span>, <span class="va">None</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> density:</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        bin_volume <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> limits <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>            bin_volume <span class="op">=</span> get_bin_volume(limits, Z.shape)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        Z <span class="op">=</span> normalize(Z, bin_volume)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Z</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_rec(Z, Z_true, suptitle<span class="op">=</span><span class="st">""</span>):</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    fig, axs <span class="op">=</span> pplt.subplots(ncols<span class="op">=</span><span class="dv">3</span>, figsize<span class="op">=</span>(<span class="fl">7.25</span>, <span class="fl">2.5</span>))</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].pcolormesh(xcenters, ycenters, Z.T, cmap<span class="op">=</span><span class="st">"dusk_r"</span>)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].pcolormesh(xcenters, ycenters, Z_true.T, cmap<span class="op">=</span><span class="st">"dusk_r"</span>)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">2</span>].pcolormesh(</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        xcenters,</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        ycenters,</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        (Z <span class="op">-</span> Z_true).T,</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>        colorbar<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>        colorbar_kw<span class="op">=</span><span class="bu">dict</span>(width<span class="op">=</span><span class="fl">0.075</span>, ticklabelsize<span class="op">=</span><span class="dv">8</span>),</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    axs.<span class="bu">format</span>(xticks<span class="op">=</span>[], yticks<span class="op">=</span>[], suptitle<span class="op">=</span>suptitle)</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axs, [<span class="st">"Reconstructed"</span>, <span class="st">"Original"</span>, <span class="st">"Error"</span>]):</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>        ax.set_title(title)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig, axs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="filtered-back-projection-fpb" class="level3">
<h3 class="anchored" data-anchor-id="filtered-back-projection-fpb">Filtered Back-Projection (FPB)</h3>
<p>In filtered back-projection (FBP) each projection is Fourier transformed and then smeared back across the <span class="math inline">\(x\)</span>-<span class="math inline">\(x'\)</span> plane. The Fourier transform acts as a filter and creates a sharper image.</p>
<div id="2d90b222-b8ec-40ba-9645-7692cbd6d232" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> transform.iradon(projections, theta<span class="op">=-</span>angles).T</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> process(Z, keep_positive<span class="op">=</span><span class="va">True</span>, density<span class="op">=</span><span class="va">True</span>, limits<span class="op">=</span>limits)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plot_rec(Z, Z_true, <span class="st">'FBP'</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_FBP.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="_output_FBP.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a></p>
</figure>
</div>
<p>FBP generally requires a high number of projections to avoid these streaking artifacts. Let’s see what happens when the number of projections is varied. In each case, we distribute the angles evenly over 180 degrees.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_vary_n_angles.gif" class="lightbox" data-gallery="quarto-lightbox-gallery-4"><img src="_output_vary_n_angles.gif" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></a></p>
</figure>
</div>
<p>We were also careful to choose an angular range close to 180 degrees to maximize the information carried by the projections.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_vary_angular_range.gif" class="lightbox" data-gallery="quarto-lightbox-gallery-5"><img src="_output_vary_angular_range.gif" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></a></p>
</figure>
</div>
<p>The angular range in an accelerator is determined by the amount of control we have over the optics between the reconstruction location and the measurement location. It’s possible to run into problems here; for example, varying a magnet too far from its design value could make the beam unacceptably large at a downstream location. Magnets also have limited strengths, and sometimes they can’t be controlled independently. Additionally, achieving a specific projection angle is not always straightforward; usually an optimizer is used to find the correct settings, and this takes time. I’ll come back to these points later.</p>
<p>FBP can be generalized to 3D reconstruction from 2D projections, but it doesn’t seem straightforward. I don’t know if it could work for a 4D reconstruction from 2D projections. I’m just not sure what back-projection would mean in that case…</p>
</section>
<section id="algebraic-reconstruction-art" class="level3">
<h3 class="anchored" data-anchor-id="algebraic-reconstruction-art">Algebraic Reconstruction (ART)</h3>
<p>Algebraic reconstruction (ART) algorithms are simpler than FBP. The reconstructed <span class="math inline">\(x\)</span>-<span class="math inline">\(x'\)</span> distribution will be defined on a grid. Let <span class="math inline">\(\rho^{(k)}\)</span> be a vector containing the <span class="math inline">\(k\)</span>th projection, and let <span class="math inline">\(\psi\)</span> be a vector of the phase space density at the reconstruction location (<span class="math inline">\(N^2\)</span> elements for an <span class="math inline">\(N \times N\)</span> grid). Since we know the linear transformation connecting the two points, we can write the following matrix equation:</p>
<p><span class="math display">\[ \rho^{(k)} = P^{(k)}\psi, \]</span></p>
<p>Stack these equations for all the projections to get</p>
<p><span class="math display">\[ \rho = P \psi. \]</span></p>
<p>All we need to do is invert these equations. The problem is that <span class="math inline">\(P\)</span> could be huge. If there are <span class="math inline">\(K\)</span> projections, <span class="math inline">\(P\)</span> will be have <span class="math inline">\(K N \times N^2\)</span> elements. Inverting such a matrix could be a pain, so people have developed iterative methods to find the answer. Scikit-image has one ready to go called simultaneous algebraic reconstruction (SART).</p>
<div id="29546c4d-4a27-4a56-87d2-2373582d07f1" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> transform.iradon_sart(projections, theta<span class="op">=-</span>angles).T</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> process(Z, keep_positive<span class="op">=</span><span class="va">True</span>, density<span class="op">=</span><span class="va">True</span>, limits<span class="op">=</span>limits)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plot_rec(Z, Z_true, <span class="st">'SART (1 iteration)'</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_SART.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6"><img src="_output_SART.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a></p>
</figure>
</div>
<p>The SART algorithm looks like it does better with fewer projections. SART is known to produce a good answer in only one iteration. Running it again with the original reconstruction as an initial estimate can sharpen image but may increase noise. In this case, it looks like running SART again leads to a better reconstruction without increasing noise.</p>
<div id="5553c79a-27b6-40a5-923a-ae62ae31b78c" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> transform.iradon_sart(projections, theta<span class="op">=-</span>angles).T</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> transform.iradon_sart(projections, theta<span class="op">=-</span>angles, image<span class="op">=</span>Z.T).T</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> process(Z, keep_positive<span class="op">=</span><span class="va">True</span>, density<span class="op">=</span><span class="va">True</span>, limits<span class="op">=</span>limits)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plot_rec(Z, Z_true, <span class="st">'SART (2 iterations)'</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_SART2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7"><img src="_output_SART2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a></p>
</figure>
</div>
<p>ART easily generalizes to 4D, but it could become expensive since <span class="math inline">\(P\)</span> would have <span class="math inline">\(K N^2 \times N^4\)</span> elements. This has been carried out by Wolski (2020) with <span class="math inline">\(N = 69\)</span>. I’ll leave investigation of 4D ART for a future post.</p>
</section>
<section id="ment" class="level3">
<h3 class="anchored" data-anchor-id="ment">MENT</h3>
<p>There is another approach to the problem based on information theory. The idea is that the most probable distribution should be chosen, i.e., find the <span class="math inline">\(f(\mathbf{x})\)</span> that maximizes the entropy</p>
<p><span class="math display">\[ S = -\int f(\mathbf{x}) \log{f(\mathbf{x})} d\mathbf{x}\]</span></p>
<p>with the constraint that the projections of <span class="math inline">\(f(\mathbf{x}\)</span> are consistent with measurements. The theory behind this algorithm is layed out in Minerbo (1972). The benefit to MENT is that it has a goal in mind and can do very well with only a few projections where ART might introduce significant streaking artifacts. The downside of MENT is that although it <em>can</em> work well with few projections, there is no guarantee, and it may struggle to converge when many projections are used. Unfortunately, this algorithm is a bit tricky to implement; I’m working on it.</p>
<p>MENT can also work in 4D with 2D projections <em>or 1D projections</em>; the math is pretty much the same.</p>
</section>
<section id="grid-based-methods" class="level3">
<h3 class="anchored" data-anchor-id="grid-based-methods">Grid-based methods</h3>
<p>There is a final method that I should mention: using multi-particle simulation to find the answer. Start with a bunch of particles and transport them to the measurement location. Throw away particles that landed in bins in which the measured projection is zero. Now, generate new particles in the viscinity of the old ones with the number of new particles proportional to the measured distribution in that bin. Repeat until convergence.</p>
<p>The advantage of this approach is that it works for any number of dimesions and can also include nonlinear effects in the simulation such as space charge. I’m wondering, though, if this just reduces to a version of ART if the transport is linear; our beam is high energy, which means that space charge can mostly be ignored over short distances. Again, I’ll leave this method for a future post.</p>
</section>
</section>
<section id="d-reconstruction-1" class="level2">
<h2 class="anchored" data-anchor-id="d-reconstruction-1">4D reconstruction</h2>
<p>I’ve mentioned that at least three methods (ART, MENT, grid-based) will generalize to 4D reconstruction from 2D projections. But what I’d like to look at now is a different, hopefully easier method described in Hock (2013). The method uses 2D projections but only uses 2D reconstruction methods like those described in this post. It’s sort of like a CT scan: 1D projections are used to reconstruct a 2D slice of a human body, and then the slice is moved along the body to reconstruct the 3D image. This would be nice because the conditions for a good 2D reconstruction are well-understood, but might not be clear for higher-dimensional versions of the algorithms.</p>
<p>First, we need a 4D distribution.</p>
<div id="38a29458-445b-4f6c-80b8-1869b24a41c2" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a rigid rotating distribution.</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.random.normal(size<span class="op">=</span>(<span class="dv">400000</span>, <span class="dv">4</span>))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.apply_along_axis(<span class="kw">lambda</span> row: row <span class="op">/</span> np.linalg.norm(row), <span class="dv">1</span>, X)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>X[:, <span class="dv">3</span>] <span class="op">=</span> <span class="op">+</span>X[:, <span class="dv">0</span>]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>X[:, <span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span>X[:, <span class="dv">2</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Change the x-y phase difference.</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> np.zeros((<span class="dv">4</span>, <span class="dv">4</span>))</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>R[:<span class="dv">2</span>, :<span class="dv">2</span>] <span class="op">=</span> rotation_matrix(np.pi <span class="op">/</span> <span class="dv">4</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>R[<span class="dv">2</span>:, <span class="dv">2</span>:] <span class="op">=</span> rotation_matrix(<span class="fl">0.0</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.apply_along_axis(<span class="kw">lambda</span> row: np.matmul(R, row), <span class="dv">1</span>, X)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Add some noise.</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>X <span class="op">+=</span> np.random.normal(scale<span class="op">=</span><span class="fl">0.4</span>, size<span class="op">=</span>X.shape)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the 2D projections.</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>n_bins <span class="op">=</span> <span class="dv">80</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> [<span class="st">"x"</span>, <span class="st">"x'"</span>, <span class="st">"y"</span>, <span class="st">"y'"</span>]</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> psv.cloud.corner(</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    X, bins<span class="op">=</span>n_bins, grid_kws<span class="op">=</span><span class="bu">dict</span>(figwidth<span class="op">=</span><span class="fl">5.5</span>), mask<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    labels<span class="op">=</span>labels,</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>limits <span class="op">=</span> [ax.get_xlim() <span class="cf">for</span> ax <span class="kw">in</span> g.axs[<span class="op">-</span><span class="dv">1</span>, :]]</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_corner.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8"><img src="_output_corner.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:75.0%"></a></p>
</figure>
</div>
<p>We can estimate the distribution by binning the particles on a 4D grid.</p>
<div id="d950960a-741b-4c2c-9101-baf2ed0579ab" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Z_true, edges <span class="op">=</span> np.histogramdd(X, n_bins, limits, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>centers <span class="op">=</span> []</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _edges <span class="kw">in</span> edges:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    centers.append(<span class="fl">0.5</span> <span class="op">*</span> (_edges[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> _edges[<span class="dv">1</span>:]))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>bin_volume <span class="op">=</span> get_bin_volume(limits, n_bins)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="description-of-hocks-method" class="level3">
<h3 class="anchored" data-anchor-id="description-of-hocks-method">Description of Hock’s method</h3>
<p>Now for the method. Suppose we can independently rotate the <span class="math inline">\(x\)</span>-<span class="math inline">\(x'\)</span> and <span class="math inline">\(y\)</span>-<span class="math inline">\(y'\)</span> projections of the phase space distribution. Let the angles in <span class="math inline">\(x\)</span>-<span class="math inline">\(x'\)</span> be <span class="math inline">\(\left\{\mu_{x_1}, \dots, \mu_{x_k}, \dots, \mu_{x_K}\right\}\)</span> and the angles in <span class="math inline">\(y\)</span>-<span class="math inline">\(y'\)</span> be <span class="math inline">\(\left\{\mu_{y_1}, \dots, \mu_{y_l}, \dots, \mu_{y_L}\right\}\)</span>. For each combination of <span class="math inline">\(\mu_x\)</span> and <span class="math inline">\(\mu_y\)</span>, we measure the beam intensity on a screen. In other words, we create a matrix <span class="math inline">\(S\)</span> such that <span class="math inline">\(S_{ijkl}\)</span> gives the intensity at point <span class="math inline">\((x_i, y_j)\)</span> on the screen for phase advances (angles) <span class="math inline">\(\mu_{x_k}\)</span> and <span class="math inline">\(\mu_{y_l}\)</span>.</p>
<div id="344a17c1-077b-4220-a475-d64d2739132b" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">15</span> <span class="co"># number of angles in x dimension</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="dv">15</span> <span class="co"># number of angles in y dimension</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>muxx <span class="op">=</span> muyy <span class="op">=</span> np.linspace(<span class="fl">0.</span>, <span class="fl">180.</span>, K, endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>xx_list <span class="op">=</span> []</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> mux <span class="kw">in</span> muxx:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    Mx <span class="op">=</span> rotation_matrix(np.radians(mux))</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    xx_list.append(<span class="bu">apply</span>(Mx, X[:, :<span class="dv">2</span>])[:, <span class="dv">0</span>])</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>yy_list <span class="op">=</span> []</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> muy <span class="kw">in</span> muyy:</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    My <span class="op">=</span> rotation_matrix(np.radians(muy))</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    yy_list.append(<span class="bu">apply</span>(My, X[:, <span class="dv">2</span>:])[:, <span class="dv">0</span>])</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.zeros((n_bins, n_bins, K, L))</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k, xx <span class="kw">in</span> <span class="bu">enumerate</span>(xx_list):</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l, yy <span class="kw">in</span> <span class="bu">enumerate</span>(yy_list):</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        S[:, :, k, l], _, _ <span class="op">=</span> np.histogram2d(xx, yy, n_bins, (limits[<span class="dv">0</span>], limits[<span class="dv">2</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_target_phase_scan.gif" class="lightbox" data-gallery="quarto-lightbox-gallery-9"><img src="_output_target_phase_scan.gif" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></a></p>
</figure>
</div>
<p>The above animation shows a few steps in the scan; since the transfer matrices are rotation matrices, only the cross-plane correlation changes.</p>
<p>We can immediately reconstruct the 3D projection the 4D phase space distribution using this data. Consider one row of the beam image — the intensity along the row gives a 1D projection onto the <span class="math inline">\(x\)</span> axis for a vertical slice of the beam. We have a set of these 1D projections at different <span class="math inline">\(\mu_k\)</span> which we can use to reconstruct the <span class="math inline">\(x\)</span>-<span class="math inline">\(x'\)</span> distribution at this vertical slice using any 1D <span class="math inline">\(\rightarrow\)</span> 2D reconstruction method. I’ll use SART since this seemed to work well with 15 projections. We repeat this at each slice. We thus have an array <span class="math inline">\(D\)</span> such that <span class="math inline">\(D_{j,l,r,s}\)</span> gives the density at <span class="math inline">\(x = x_r\)</span>, <span class="math inline">\(x' = x'_s\)</span> for <span class="math inline">\(y = y_j\)</span> and <span class="math inline">\(\mu_y = \mu_{y_l}\)</span>.</p>
<div id="961e753f-ce76-4f02-8bb2-f1b1dd409a45" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> np.zeros((n_bins, L, n_bins, n_bins))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_bins):</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(L):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        _Z <span class="op">=</span> transform.iradon_sart(S[:, j, :, l], theta<span class="op">=-</span>muxx).T</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        _Z <span class="op">=</span> transform.iradon_sart(S[:, j, :, l], theta<span class="op">=-</span>muxx, image<span class="op">=</span>_Z.T).T</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        D[j, l, :, :] <span class="op">=</span>_Z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>I should also mention that the reconstruction grid doesn’t need to be the same size as the measurement grid. We can now do a similar thing in the vertical plane. For each bin in the reconstructed x-x’ grid, <code>D[:, :, r, s]</code> gives the projections of <span class="math inline">\(y\)</span>-<span class="math inline">\(y'\)</span> at each <span class="math inline">\(\mu_{y_l}\)</span>; thus, <span class="math inline">\(y\)</span>-<span class="math inline">\(y'\)</span> can be reconstructed at each <span class="math inline">\(x_r\)</span> and <span class="math inline">\(x'_s\)</span>, and we have an array <span class="math inline">\(Z\)</span> such that <span class="math inline">\(Z_{r,s,t,u}\)</span> gives the density at <span class="math inline">\(x = x_r\)</span>, <span class="math inline">\(x' = x'_s\)</span>, <span class="math inline">\(y = y_t\)</span>, <span class="math inline">\(y' = y'_u\)</span>.</p>
<div id="13dd09c1-3939-4ff7-a633-6b53cf3ab175" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> np.zeros((n_bins, n_bins, n_bins, n_bins))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(n_bins):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(n_bins):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        _Z <span class="op">=</span> transform.iradon_sart(D[:, :, r, s], theta<span class="op">=-</span>muyy).T</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        _Z <span class="op">=</span> transform.iradon_sart(D[:, :, r, s], theta<span class="op">=-</span>muyy, image<span class="op">=</span>_Z.T).T</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        Z[r, s, :, :] <span class="op">=</span> _Z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="accuracy" class="level3">
<h3 class="anchored" data-anchor-id="accuracy">Accuracy</h3>
<p>SART could make some bins negative, so set those to zero. We then need to normalize <code>Z</code> for comparison with <code>Z_true</code>.</p>
<div id="7d2db923-5017-4f14-89d9-a10958ba81f5" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> process(Z, keep_positive<span class="op">=</span><span class="va">True</span>, density<span class="op">=</span><span class="va">True</span>, limits<span class="op">=</span>limits)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'min(Z) = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(np.<span class="bu">min</span>(Z)))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'max(Z) = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(np.<span class="bu">max</span>(Z)))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'sum(Z) * bin_volume = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(np.<span class="bu">sum</span>(Z) <span class="op">*</span> bin_volume))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'min(Z_true) = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(np.<span class="bu">min</span>(Z_true)))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'max(Z_true) = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(np.<span class="bu">max</span>(Z_true)))</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'sum(Z_true) * bin_volume = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(np.<span class="bu">sum</span>(Z_true) <span class="op">*</span> bin_volume))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>min(Z) = 0.0
max(Z) = 0.17036653561113582
sum(Z) * bin_volume = 0.9999999999999999

min(Z_true) = 0.0
max(Z_true) = 1.3628864309355835
sum(Z_true) * bin_volume = 0.9999999999999879</code></pre>
</div>
</div>
<p>I’m not sure the best way to quantify the difference between the distributions. My initial thought is to subtract <code>Z_true</code> from <code>Z</code>, take the absolute value, and divide by the number of bins; this would give the average absolute error over the bins.</p>
<div id="82664ac4-65c6-41ec-b78c-7f60f69d6ddd" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>avg_abs_err_per_bin <span class="op">=</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(Z <span class="op">-</span> Z_true)) <span class="op">/</span> Z.size</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Average absolute error per bin = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(avg_abs_err_per_bin))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Average absolute error per bin = 0.002540311656083561</code></pre>
</div>
</div>
<p>Lots of bins are empty so this might not be the most meaningful number. For now, it’s probably more helpful to view the differences between the projections.</p>
<div id="5963d695-f562-485b-9f9c-134293504176" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> pplt.subplots(ncols<span class="op">=</span><span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">2</span>), spanx<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    axs[i].plot(centers[i], project(Z_true, i), color<span class="op">=</span><span class="st">'black'</span>, label<span class="op">=</span><span class="st">'True'</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    axs[i].plot(centers[i], project(Z, i), color<span class="op">=</span><span class="st">'red8'</span>, ls<span class="op">=</span><span class="st">'dotted'</span>, label<span class="op">=</span><span class="st">'Reconstructed'</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    axs[i].set_xlabel(labels[i])</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].legend(loc<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">1.02</span>), framealpha<span class="op">=</span><span class="fl">0.0</span>, ncol<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_compare_1d.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10"><img src="_output_compare_1d.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></a></p>
</figure>
</div>
<div id="a490aa65-1fb1-46b4-8b6a-28756da177f3" class="cell" data-execution_count="33">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">0</span>, <span class="dv">2</span>), (<span class="dv">0</span>, <span class="dv">3</span>), (<span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">3</span>)]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> pplt.subplots(nrows<span class="op">=</span><span class="dv">6</span>, ncols<span class="op">=</span><span class="dv">3</span>, figwidth<span class="op">=</span><span class="fl">5.0</span>, sharex<span class="op">=</span><span class="va">False</span>, sharey<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row, (i, j) <span class="kw">in</span> <span class="bu">enumerate</span>(indices):</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    _Z_true <span class="op">=</span> project(Z_true, [i, j])</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    _Z <span class="op">=</span> project(Z, [i, j])</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    axs[row, <span class="dv">0</span>].pcolormesh(centers[i], centers[j], _Z.T)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    axs[row, <span class="dv">1</span>].pcolormesh(centers[i], centers[j], _Z_true.T)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    axs[row, <span class="dv">2</span>].pcolormesh(</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        centers[i],</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        centers[j],</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        (_Z <span class="op">-</span> _Z_true).T,</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        colorbar<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        colorbar_kw<span class="op">=</span><span class="bu">dict</span>(width<span class="op">=</span><span class="fl">0.075</span>),</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    axs[row, <span class="dv">0</span>].annotate(</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">"</span><span class="sc">{}</span><span class="st">-</span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(labels[i], labels[j]),</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        xy<span class="op">=</span>(<span class="fl">0.02</span>, <span class="fl">0.92</span>),</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        xycoords<span class="op">=</span><span class="st">"axes fraction"</span>,</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">"white"</span>,</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axs[<span class="dv">0</span>, :], [<span class="st">"Reconstructed"</span>, <span class="st">"True"</span>, <span class="st">"Error"</span>]):</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title)</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>axs.<span class="bu">format</span>(xticks<span class="op">=</span>[], yticks<span class="op">=</span>[])</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="_output_compare_2d.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11"><img src="_output_compare_2d.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:65.0%"></a></p>
</figure>
</div>
<p>In the second plot, the error is given in number of particles. It looks like the method worked well to reconstruct this distribution. [Edit 2023-02-13: This is not a sufficient comparison in 4D: one needs to look at slices, and use more complex distribution.]</p>
</section>
</section>
<section id="feasibility" class="level2">
<h2 class="anchored" data-anchor-id="feasibility">Feasibility</h2>
<section id="imaging-system" class="level3">
<h3 class="anchored" data-anchor-id="imaging-system">Imaging system</h3>
<p>The SNS target is a steel vessel containing liquid mercury. At the beginning of this post, I mentioned that the SNS has a target imaging system. Here is a diagram showing how the target imaging system works…</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="target_image_system.png" class="lightbox" data-gallery="quarto-lightbox-gallery-12"><img src="target_image_system.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></a></p>
</figure>
</div>
<p>… and an example of an image.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="target_image.png" class="lightbox" data-gallery="quarto-lightbox-gallery-13"><img src="target_image.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></a></p>
</figure>
</div>
<p>To reduce noise, the image was averaged over five beam pulses and a Gaussian blur was applied with <span class="math inline">\(\sigma = 3\)</span>. There are four fiducial markers that are visible as dark spots on the corner of the beam. The black ellipse represents a measurement from wire-scanners upstream of the target. Collecting this image is easy.</p>
</section>
<section id="optics-control" class="level3">
<h3 class="anchored" data-anchor-id="optics-control">Optics control</h3>
<p>I’ve assumed that the transfer matrices connecting the coordinates are simple rotation matrices. Although that isn’t true in reality, there is a trick we can play. Any transfer matrix <span class="math inline">\(M\)</span> can be writen as the product <span class="math inline">\(M = V R V^{-1}\)</span>, where <span class="math inline">\(V\)</span> provides shearing + scaling and <span class="math inline">\(R\)</span> is a rotation by the phase advances <span class="math inline">\(\mu_x\)</span> and <span class="math inline">\(\mu_y\)</span>. Applying <span class="math inline">\(V^{-1}\)</span> to the coordinates is called <em>normalizing</em> the coordinates. What we can do is normalize (scale) the measured profiles, perform the reconstruction in normalized phase space, then unnormalize the reconstructed distribution.</p>
<p>In normalized phase space, the transfer matrices are just rotation matrices (<span class="math inline">\(R\)</span>) and the projection angles are the phase advances. This is an advantage because the phase advances are easier to control than the true projection angles. Also, the reconstructed <span class="math inline">\(x\)</span>-<span class="math inline">\(x'\)</span> and <span class="math inline">\(y\)</span>-<span class="math inline">\(y'\)</span> projections will be somewhat circular in this space, which should reduce errors.</p>
<p>The (un)normalization steps will involve interpolation since we’re performing a transformation on an image, and I’m not yet sure how this will affect the reconstruction error. Anyhow, we don’t <em>have</em> to reconstruct in normalized phase space if this turns out to be an issue.</p>
<p>So, the question is whether we can independently vary the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> phase advances at the target, and if so, by how much. There are five independent quadrupoles before the target — three focusing and two defocusing — QH26, QV27, QH28, QV29 and QH30. Before that, there are eight quadrupoles — four focusing and four defocusing — that share two powers supplies. One power supply controls QH18, QH20, QH22, and QH24, and another controls QV19, QV21, QV23, and QV25.</p>
<p>There are also a constraints. First, the beam size far away from the target should remain small. We measure the beam size using the <span class="math inline">\(\beta\)</span> function, which should remain below 35 [m/rad]. The beam becomes much larger close to the target; there, the <span class="math inline">\(\beta\)</span> function should remain below 100 [m/rad]. Finally, the SNS target has tight constraints on the beam size and the beam density. It’s safest to keep the <span class="math inline">\(\beta\)</span> functions within 10 or 20 percent of the design value.</p>
<p>I plugged all this into an optimizer and asked to vary the phase advances in a 180 degree range. After fideling with the starting and ending phases, I was able to more-or-less do this. I used 15 phase advances in <span class="math inline">\(x\)</span> and 15 phase advances in <span class="math inline">\(y\)</span>, just like in this post. Each optimization took around 16 seconds, so the script took around an hour to run. Below are the computed phase advances at each step as well as the strengths of the seven magnet power supplies.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="target_phase_scan1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-14"><img src="target_phase_scan1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:75.0%"></a></p>
</figure>
</div>
<p>There are a few steps near the end of the scan in which the phase advances aren’t exactly correct, but they are close. I can always decrease the phase coverage slighly, or maybe these steps just need a slightly different initial guess. Here are the beta functions for all steps in one plot. The plot ends at the target.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="target_phase_scan2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-15"><img src="target_phase_scan2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:75.0%"></a></p>
</figure>
</div>
<p>The bottom plot is just the integral of the inverse of the top plot. The beta functions remain within their limits.</p>
</section>
<section id="outlook" class="level3">
<h3 class="anchored" data-anchor-id="outlook">Outlook</h3>
<p>Initial tests of Hock’s 4D reconstruction method are promising. There are a number of things to investigate. Ideally, the minimum number of projections is used. First, I should play with the number of projections using ART to see how the reconstruction error scales. I would also like to implement MENT, which should do better with fewer projections. I should then test the “direct” 4D reconstruction methods such as ART, MENT, or grid-based and compare them to Hock’s method. I should also investigate how the methods respond to noise, changes in the grid size, and more complex distributions.</p>
<p>The script to perform the data collection for this method is pretty simple: compute the correct optics, update the live magnet strengths accordingly, send a beam to the target, and save the target image. The biggest issue is execution time. In our next study at the SNS, we’ll have plenty of time to run the script in addition to our other tasks. Hopefully this will be a helpful diagnostic.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","loop":false,"openEffect":"zoom","selector":".lightbox","descPosition":"bottom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>