<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Austin Hoover">
<meta name="dcterms.date" content="2021-05-27">

<title>Accelerated Inquiry - Painting a particle beam</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Accelerated Inquiry</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about/index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Painting a particle beam</h1>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Austin Hoover </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 27, 2021</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>There is a great scene in the otherwise disappointing movie <em>Iron Man 2</em> in which Tony Stark builds a particle accelerator in his house.</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/y0brSA1cyzw" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<p>The movie makes it look like a complicated process, but modern large-scale accelerators are immensely more complicated than the one Stark builds. In fact, I’m amazed that such machines have been built <em>and work as expected</em>. One example is the Spallation Neutron Source (SNS).</p>
<section id="a-quick-tour-of-the-sns" class="level2">
<h2 class="anchored" data-anchor-id="a-quick-tour-of-the-sns">A quick tour of the SNS</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="sns.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Fig. 1. Overhead view of the SNS.</figcaption>
</figure>
</div>
<p>The goal of the SNS is to produce extremely bright, pulsed neutron beams for neutron scattering experiments. These neutrons are produced through the process of <a href="https://inis.iaea.org/collection/NCLCollectionStore/_Public/23/015/23015552.pdf">spallation</a> by colliding a proton beam with a Mercury target. The power of the proton beam must be as high as possible to maximize the brightness of the neutron beam, and creating such a high-power beam is a multi-step process; particles must travel all the way from the ion source on the far left to the target on the far right, passing though many different sections on their journey. We’re first going to mention the basic function of each of these sections, and then we’re going to look in more detail at the relatively small but extremely important <em>injection region</em> of the machine. This is the point where the HEBT meets the accumulator ring in the above diagram.</p>
<section id="ion-source-front-end-and-linac" class="level3">
<h3 class="anchored" data-anchor-id="ion-source-front-end-and-linac">Ion source, front end, and linac</h3>
<p>The beam originates in the ion source. As explained later, the beam is not actually made of protons at this point, but is instead made of H<span class="math inline">\(^-\)</span> ions (proton + two electrons). The ion source consists of a vacuum chamber filled with gas, and an oscillating electric field which ionizes the gas to form a glowing, pink plasma. The H<span class="math inline">\(^-\)</span> particles are then extracted from the plasma; I asked one of the researchers at SNS (who doesn’t work on the ion source) how exactly these ions are extracted, and they said it’s “black magic”, so I guess it’s not straightforward.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ion_source.png" class="img-fluid figure-img" style="width:65.0%"></p>
<figcaption>Fig. 2. Diagram of the SNS ion source. (Source:<span class="citation" data-cites="Henderson2014">&nbsp;[<a href="#ref-Henderson2014" role="doc-biblioref">1</a>]</span>.)</figcaption>
</figure>
</div>
<p>The H<span class="math inline">\(^-\)</span> beam is then accelerated to around 2.5 MeV, focused, and “chopped” into 1000 <em>minipulses</em>. Each minipulse is about 700 nanoseconds long, and they’re separated by a gap of about 300 nanoseconds. The dynamics in this region are strongly influenced by space charge.</p>
<p>Each minipulse is now ready to be accelerated. The next section of the machine is called the linac (linear accelerator), a long, straight section whose purpose is to accelerate the minipulses up to 1 GeV (around 90% of the speed of light) while maintaining an acceptable beam size. This is done using a series of normal-conducting and superconducting radio-frequency cavities. There is a lot to talk about in the linac, but I’ll stop here since I don’t have much knowledge of this area of the machine yet.</p>
</section>
<section id="hebt-injection-region-and-accumulator-ring" class="level3">
<h3 class="anchored" data-anchor-id="hebt-injection-region-and-accumulator-ring">HEBT, injection region, and accumulator ring</h3>
<p>The high-energy beam transport (HEBT, pronounced “hebbet”) guides the fully accelerated minipulse from the linac to the left edge of the accumulator ring. At this point, all the ions in the minipulse are converted to protons and <em>injected</em> into the accumulator ring (more on this in the next section). The minpulse takes 1 microsecond to travel around the ring, at which point a second minipulse is injected and the circulating beam doubles in intensity. This repeats 1000 times over the course of one millisecond until the final beam, called a <em>pulse</em>, contains around <span class="math inline">\(1.5 \times 10^{14}\)</span> protons. That seems like a lot until you consider that Avagadros number is one billion times larger! 60 of these pulses contains about the same energy as a stick of dynamite.</p>
</section>
<section id="rtbt-and-target" class="level3">
<h3 class="anchored" data-anchor-id="rtbt-and-target">RTBT and target</h3>
<p>Finally, the entire pulse is extracted from the ring and travels down the ring-target-beam-transport (RTBT) in which it is directed to the Mercury target, producing neutrons. These neutrons are then cooled and transported to various instrumental halls for use in neutron scattering experiments.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="target.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Fig. 3. Protons (yellow) bombard the Mercury target to produce neutrons (blue). Source: Jill Hemman.</figcaption>
</figure>
</div>
</section>
</section>
<section id="injection" class="level2">
<h2 class="anchored" data-anchor-id="injection">Injection</h2>
<p>Now we’re going to discuss the injection region in more detail (see image below). Somehow, all the negatively charged ions need to be converted to positively charge protons, and the beam from the linac needs to merge with the circulating beam in the ring without derailing its trajectory; it’s as if the ions were trying to merge onto a busy highway. The specific method used at SNS is <em>charge exchange</em> injection, which we discuss first. We’ll then move on to discuss <em>phase space painting</em>, which is used to mitigate the effects of space charge in intense beams.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="injection_region4.png" class="img-fluid figure-img" style="width:35.0%"></p>
<figcaption>Fig. 4. THe SNS injection region.</figcaption>
</figure>
</div>
<section id="h--charge-exchange" class="level3">
<h3 class="anchored" data-anchor-id="h--charge-exchange">H<span class="math inline">\(^-\)</span> charge exchange</h3>
<p>Consider two oppositely charged beams which have the same kinetic energy but opposite charges. Also assume that we’re dealing with point particles which do not interact with each other and have no transverse velocity. If these beams are sent thought a dipole magnet, their paths will be bent in opposite directions with the same radius of curvature. If they additionally have opposite angles of incidence, there will be a point in the dipole at which both beams are moving parallel to each other. Now imagine that, at this very instance, the charge of all the particles in one of the beams changes sign. The two beams would then be identical and would continue along the same trajectory, although there may be an offset. It’s possible to also choose the horizontal and vertical positions of the two beams such that they converge and travel along identical paths.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="bend.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Fig. 5. Oppositely charged particles are bent in different directions in a dipole magnetic field.</figcaption>
</figure>
</div>
<p>The idea is to do this with the two beams in the SNS: the negatively charged H<span class="math inline">\(^-\)</span> beam the linac and the positively charged proton beam which is circulating in the ring. Russian scientists developed a method to do this in the 1960’s using a thin foil which <em>strips</em> the two electrons from the Hydrogen ions but leaves the protons. The foil properties need to be chosen carefully. It needs to be the right material and thick enough to have a high stripping efficiency (number of ions successfully stripped divided by total number of ions), but not so thick that most of the protons are scattered. It also needs to be able to survive high numbers of foil hits without being destroyed. Thus, the choice of foil parameters requires a knowledge of materials science. The SNS uses diamond foils as in the following images.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="foil.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Fig. 6. Stripper foil used for charge-exchange injection at the SNS.</figcaption>
</figure>
</div>
</section>
<section id="dealing-with-extra-particles" class="level3">
<h3 class="anchored" data-anchor-id="dealing-with-extra-particles">Dealing with extra particles</h3>
<p>Some of the H<span class="math inline">\(^-\)</span> hold on to their electrons as they pass through the foil, and some only lose one electron, becoming H<span class="math inline">\(^0\)</span>. To deal with these particles, the foil is placed in a dipole field. Because many of the H<span class="math inline">\(^0\)</span> particles are in excited states, it is likely that their electron will be stripped by the magnetic field soon after the foil; this is known as <em>Lorentz stripping</em>. So a lot of these will become protons and join the circulating beam, just a bit late to the party. The remaining non-protons continue away from the ring and encounter <em>another foil</em> which removes the electrons so that they can be guided to a beam dump. There is also the need to catch the stripped electrons, which can have significant kinetic energies, but I won’t discuss that here.</p>
</section>
<section id="is-liouvilles-theorem-violated" class="level3">
<h3 class="anchored" data-anchor-id="is-liouvilles-theorem-violated">Is Liouville’s theorem violated?</h3>
<p>Those familiar with Liouville’s theorem may object to the charge-exchange method. Liouville’s theorem applies to any system which obeys Hamilton’s equations:</p>
<p><span class="math display">\[ \dot{\mathbf{q}} = \frac{\partial\mathbf{H}}{\partial\mathbf{p}} ,\quad \dot{\mathbf{p}} = -\frac{\partial\mathbf{H}}{\partial\mathbf{q}},\]</span></p>
<p>where <span class="math inline">\(\mathbf{q}\)</span> are the coordinates and <span class="math inline">\(\mathbf{p}\)</span> are the momenta. Imagine we took a volume of phase space and started to fill it with particles; in fact, we fill all of the infinite number of points inside the volume. Then we evolve the system in time. The final distribution of particles may have changed shape, but Liouville’s theorem states that its volume will not have changed. Mathematically, this is due to Hamilton’s equations being equivalent to a coordinate transformation whose Jacobian has a determinant equal to one. So, the objection is that the phase space volume of the entire system (linac beam + circulating beam) seems to <em>decrease</em> when they are merged, i.e., the linac beam is stacked directly on top of the circulating beam, and that this should be disallowed by Liouville’s theorem. Is this true?</p>
<p>I read a paper by A. Ruggiero which helped to clarify this issue<span class="citation" data-cites="Ruggiero1978">&nbsp;[<a href="#ref-Ruggiero1978" role="doc-biblioref">2</a>]</span>. The key point is that Liouville’s theorem deals with <em>distributions</em> rather than finite numbers of particles. Any finite number of particles will not fill up every point in phase space, so there is nothing preventing another finite number of particles from being added to the empty regions. The limitation is that it’s not clear how to guide two beams of the same charge to the same position using dipole magnets; hence, charge exchange. I should note, however, that this does not seem to be the explanation put forth in the talks I’ve heard on this subject. I’m planning to discuss this with some other people in the field.</p>
</section>
<section id="the-future-lasers" class="level3">
<h3 class="anchored" data-anchor-id="the-future-lasers">The future: lasers</h3>
<p>A major research project at the SNS is to demonstrate laser-assisted charge exchange (LACE), in which a laser is used to excite the ions and a dipole magnet is used to strip the magnets intead of a foil. This would overcome the scattering losses from foils as well as their finite lifetimes; it is a very promising approach as machines continue to increase in power<span class="citation" data-cites="Cousineau2017">&nbsp;[<a href="#ref-Cousineau2017" role="doc-biblioref">3</a>]</span>.</p>
</section>
</section>
<section id="phase-space-painting" class="level2">
<h2 class="anchored" data-anchor-id="phase-space-painting">Phase space painting</h2>
<p>In the last section, we assumed that the particles didn’t interact with each other, but in reality, space charge is the fundamental limit on the intensity in high-power hadron accelerators. Injecting at the same position in space will cause the beam to become very dense, and the beam will then expand due to the increased space charge forces. It’s likely that this will produce a very non-uniform distribution which, as mentioned in <a href="https://austin-hoover.github.io/posts/2021-05-13_matched_envelope/2021-05-13_matched_envelope.html">this post</a>, is undesirable. This is the motivation for so-called <em>phase space painting</em> or simply <em>painting</em>. The idea is to change the transverse position and momentum of the circulating beam over time in order to slowly fill or “paint” the beam in phase space and hopefully produce a more uniform density beam. Another motivation for painting is to avoid excessive foil hits, since these lead to shorter foil lifetimes and also beam scattering.</p>
<section id="time-dependent-kicker-magnets" class="level3">
<h3 class="anchored" data-anchor-id="time-dependent-kicker-magnets">Time-dependent kicker magnets</h3>
<p>Here is a zoomed in view of the injection region.</p>
<!-- <br> -->
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="injection_region1.png" class="img-fluid figure-img" style="width:75.0%"></p>
<figcaption>Fig. 7. Zoomed view of the injection region.</figcaption>
</figure>
</div>
<!-- <br> -->
<p>The blue elements which aren’t labeled in the ring are just quadrupoles used to focus the beam. This leaves the “bump” or “kicker” magnets and the “Chicane” magnets. These are both dipoles, but they are a bit different. The chicane dipoles provide a fixed horizontal bump to the closed orbit so that it is aligned with the beam from the linac. The kickers, on the other hand, can move the closed orbit horizontally or vertically, and they’re time-dependent. Regarding the latter point, the current from the magnet’s power supply, and therefore the magnetic field, can be varied during injection. Let’s take a look at the vertical closed orbit with the kickers turned on (black line).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="injection_region.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Fig. 8. Magnets in the injection region.</figcaption>
</figure>
</div>
<p>The dark blue boxes are quadrupoles, the red boxes are Chicane dipoles, and the remaining elements are the horizontal (green) and vertical (yellow) kickers. Without the kickers, the closed orbit will just go straight through the center of each magnet, and a similar thing holds in the horizontal plane. Thus, we have control over the horizontal and vertical position of the circulating beam relative to the injected beam. But there is also the possibility that the trajectory is converging or diverging at the foil, so we also have control over the horizontal and vertical circulating beam <em>slope</em> relative to the injected beam. These eight kickers therefore give full control over the transverse phase space coordinates of the circulating beam relative to the injected beam at every point during the injection.</p>
</section>
<section id="production-painting" class="level3">
<h3 class="anchored" data-anchor-id="production-painting">Production painting</h3>
<p>The time-dependence of each kicker magnet is determined by a waveform which determines the current given to its power supply as a function of time; for example, we could have a linear waveform, square root waveform, etc. Choosing these waveforms amounts to choosing the initial and final position/slope of the circulating beam, as well as the rate of change in the position/slope. The standard “production” scheme in the SNS (as in neutron production) is to use a square root waveform so that</p>
<p><span class="math display">\[ x_{inj} - x_{co} = (x_{max} - x_{min}) \sqrt{t / t_{max}} + x_{min}, \]</span> <span class="math display">\[ y_{inj} - y_{co} = (y_{max} - y_{min}) \sqrt{t / t_{max}} + y_{min}, \]</span></p>
<p>where the <em>co</em> subscript means “closed orbit” and <em>inj</em> means “injected beam”. The slope of the circulating beam is kept at zero in this scheme.</p>
<p>It’s probably best to use some visualizations at this point. I simulated the injection painting using <a href="https://github.com/austin-hoover/py-orbit">PyORBIT</a>; included in this simulation are effects such as space charge, nonlinear magnetic fringe fields, scattering from the foil, etc., so the results should be somewhat similar to the real world. 260 simulation particles were injected on each turn to give a final number of 260,000, which should provide good statistics for the space charge solver which operates on a <span class="math inline">\(128 \times 128\)</span> transverse grid. The whole simulation took a few hours to run on my laptop. (The space charge solver I used makes some approximations in the longitudinal dimension; a more realistic solver will push the execution time from a few hours to a few days.)</p>
<p>The following animation shows this simulated beam at the injection point during the first 35 turns in the ring. The off-diagonal subplots show the correlations between the four phase space variables (a sample of 10,000 particles is used) and the on-diagonal subplots show the histograms for each variable. The foil location is shown by the red dot in the <span class="math inline">\(x\)</span>-<span class="math inline">\(y\)</span> plane.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="painting_short.gif" class="img-fluid figure-img" style="width:85.0%"></p>
<figcaption>Fig. 9. The first few turns of the injection process.</figcaption>
</figure>
</div>
<p>Keep in mind that each little cluster is actually a bunch of particles; it’s hard to resolve because the width is small compared to the full beam. Notice that, since the circulating and injected beams are offset to begin with, the injected particles start to trace ellipses in the <span class="math inline">\(x\)</span>-<span class="math inline">\(x'\)</span> and <span class="math inline">\(y\)</span>-<span class="math inline">\(y'\)</span> projections. The frequencies at which the particles oscillate in each plane are not the same, so the path in <span class="math inline">\(x\)</span>-<span class="math inline">\(y\)</span> space is constantly changing, eventually filling a rectangular region. The next animation shows the beam over all 1000 turns.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="painting_long.gif" class="img-fluid figure-img" style="width:85.0%"></p>
<figcaption>Fig. 10. All 1000 turns of the injection process.</figcaption>
</figure>
</div>
<p>Notice that the beam size is slowly increasing, and also that the density is steadily increasing; this is only apparent from the histograms since I’m using a random sample of particles in the scatter plots. Space charge, as well as nonlinear effects, tend to round the hard edges of the the originally rectangular beam. The beam also exhibits some interesting dynamics after turn 100, and again after turn 800, when it begins to tilt back and forth, which is probably due to space charge coupling the two planes. In the end, the beam has a somewhat uniform density, is not tilted, is not rotating, and is quite intense (<span class="math inline">\(1.5 \times 10^{14}\)</span> particles), so the basic goals of the painting scheme have been achieved. The beam can now be extracted and collided with the target to produce neutrons.</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-Henderson2014" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline"><em><a href="https://doi.org/10.1016/j.nima.2014.03.067">The Spallation Neutron Source Accelerator System Design</a></em>, Nuclear Instruments and Methods in Physics Research Section A: Accelerators, Spectrometers, Detectors and Associated Equipment <strong>763</strong>, 610 (2014).</div>
</div>
<div id="ref-Ruggiero1978" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">A. G. Ruggiero, <em><span class="nocase">Are We Beating Liouville’s Theorem?</span></em>, eConf <strong>C7803272</strong>, 123 (1978).</div>
</div>
<div id="ref-Cousineau2017" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">S. Cousineau, A. Rakhman, M. Kay, A. Aleksandrov, V. Danilov, T. Gorlov, Y. Liu, M. Plum, A. Shishlo, and D. Johnson, <em><a href="https://doi.org/10.1103/PhysRevLett.118.074801">First Demonstration of Laser-Assisted Charge Exchange for Microsecond Duration Beams</a></em>, Phys. Rev. Lett. <strong>118</strong>, 074801 (2017).</div>
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="austin-hoover/austin-hoover.github.io/blog" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>