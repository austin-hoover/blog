<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Austin Hoover">
<meta name="dcterms.date" content="2021-02-22">

<title>Particle-in-cell simulation – Austin’s Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-DLC4C8LZFB"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-DLC4C8LZFB', { 'anonymize_ip': true});
</script>
<script type="application/json" class="js-hypothesis-config">
{
  "theme": "clean",
  "openSidebar": false
}
</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Austin’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about/index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../links/index.html"> 
<span class="menu-text">Links</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#theoretical-model" id="toc-theoretical-model" class="nav-link active" data-scroll-target="#theoretical-model">Theoretical model</a></li>
  <li><a href="#computational-method" id="toc-computational-method" class="nav-link" data-scroll-target="#computational-method">Computational method</a>
  <ul>
  <li><a href="#weighting" id="toc-weighting" class="nav-link" data-scroll-target="#weighting">Weighting</a></li>
  <li><a href="#field-solver" id="toc-field-solver" class="nav-link" data-scroll-target="#field-solver">Field solver</a></li>
  <li><a href="#particle-mover" id="toc-particle-mover" class="nav-link" data-scroll-target="#particle-mover">Particle mover</a></li>
  </ul></li>
  <li><a href="#putting-it-all-together" id="toc-putting-it-all-together" class="nav-link" data-scroll-target="#putting-it-all-together">Putting it all together</a>
  <ul>
  <li><a href="#simulation-loop" id="toc-simulation-loop" class="nav-link" data-scroll-target="#simulation-loop">Simulation loop</a></li>
  <li><a href="#benchmark-freely-expanding-vlasov-equilibrium-distribution" id="toc-benchmark-freely-expanding-vlasov-equilibrium-distribution" class="nav-link" data-scroll-target="#benchmark-freely-expanding-vlasov-equilibrium-distribution">Benchmark: freely expanding Vlasov equilibrium distribution</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Particle-in-cell simulation</h1>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Austin Hoover </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 22, 2021</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- <br> -->
<p>There are many beam physics simulation codes. A key component of these simulations is the inclusion of the electromagnetic interactions between particles in the beam, also known as <em>space charge</em> forces. One way to compute space charge forces is the particle-in-cell (PIC) method. This post implements a basic version of the PIC method in Python.</p>
<section id="theoretical-model" class="level2">
<h2 class="anchored" data-anchor-id="theoretical-model">Theoretical model</h2>
<p>We’ll use <em>bunch</em> to refer to a group of particles in three-dimensional (3D) space, and we’ll use a local cartesian coordinate system whose origin moves with the center of the bunch as shown below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="coordinate_system.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Fig. 1. Coordinate system defined in the beam rest frame."><img src="coordinate_system.png" class="img-fluid figure-img" style="width:55.0%" alt="Fig. 1. Coordinate system defined in the beam rest frame."></a></p>
<figcaption>Fig. 1. Coordinate system defined in the beam rest frame.</figcaption>
</figure>
</div>
<p>The <span class="math inline">\(s\)</span> coordinate specifies the position of the bunch in the accelerator, and the path can be curved. Now for a few assumptions and approximations. First, assume all particles in the bunch move at a constant velocity <span class="math inline">\(\beta c\)</span>, where <span class="math inline">\(c\)</span> is the speed of light. We then make the <em>paraxial approximation</em>. It’s conventional to use the slope <span class="math inline">\(x' = dx/ds\)</span> instead of the velocity, and the paraxial approximation assumes this slope is very small. Usually we report this slope in milliradians since <span class="math inline">\(tan\theta \approx \theta\)</span> for small angles. Next we assume that the transverse (<span class="math inline">\(x\)</span>-<span class="math inline">\(y\)</span>) size of the bunch varies slowly along the <span class="math inline">\(s\)</span> axis. If this is true and we look at the electric field in a transverse slice of the bunch, there won’t be much difference between the true field and the field of an infinitely long, uniform density cylinder. Our focus will be on the transverse dynamics of such a slice, so we’ll treat each “particle” as an infinite line of charge. The figure below illustrates this approximation.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="coasting_beam.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Fig. 2. Coasting beam approximation. (Source: G. Franchetti, Space charge in circular machines, CERN Accelerator School Proceedings (2017). https://e-publishing.cern.ch/index.php/CYRSP/article/view/413)"><img src="coasting_beam.png" class="img-fluid figure-img" style="width:70.0%" alt="Fig. 2. Coasting beam approximation. (Source: G. Franchetti, Space charge in circular machines, CERN Accelerator School Proceedings (2017). https://e-publishing.cern.ch/index.php/CYRSP/article/view/413)"></a></p>
<figcaption>Fig. 2. Coasting beam approximation. (Source: G. Franchetti, <em>Space charge in circular machines</em>, CERN Accelerator School Proceedings (2017). <a href="https://e-publishing.cern.ch/index.php/CYRSP/article/view/413">https://e-publishing.cern.ch/index.php/CYRSP/article/view/413</a>)</figcaption>
</figure>
</div>
<p>Another approximation is to neglect any magnetic fields generated by the beam, which is again valid if the transverse velocities are very small relative to <span class="math inline">\(\beta c\)</span>. All this being said, the equations of motion without any external forces, i.e., in free space, can be written as</p>
<p><span id="eq-EOM"><span class="math display">\[
\mathbf{x}'' = \frac{q}{mc^2\beta^2\gamma^3} \mathbf{E},
\tag{1}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{x} = [x, y]^T\)</span> is the coordinate vector, <span class="math inline">\(\mathbf{E} = [E_x, E_y]^T\)</span> is the self-generated electric field, <span class="math inline">\(m\)</span> is the particle mass, and <span class="math inline">\(\gamma = \left({1 - \beta^2}\right)^{-1/2}\)</span>. Let’s first address the factor <span class="math inline">\(\gamma^{-3}\)</span> in the equation of motion, which means that the space charge force goes to zero as the velocity approaches the speed of light. This is because parallel moving charges generate an attractive magnetic force which grows with velocity, completely cancelling the electric force in the limit <span class="math inline">\(v \rightarrow c\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="parallel_currents.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Fig. 3. The magnetic force between parallel currents is attractive. (Source: OpenStax University Physics.)"><img src="parallel_currents.jpg" class="img-fluid figure-img" style="width:50.0%" alt="Fig. 3. The magnetic force between parallel currents is attractive. (Source: OpenStax University Physics.)"></a></p>
<figcaption>Fig. 3. The magnetic force between parallel currents is attractive. (Source: OpenStax University Physics.)</figcaption>
</figure>
</div>
<p>One may ask: what about the rest frame in which there is no magnetic field? But special relativity says that electrogmagnetic fields change with reference frame. Using the transformations defined <a href="https://en.wikipedia.org/wiki/Classical_electromagnetism_and_special_relativity">here</a>, you can quickly prove that</p>
<p><span id="eq-Lorentz"><span class="math display">\[
\mathbf{E}_{lab} = \frac{\mathbf{E}_{rest}}{\gamma}.
\tag{2}\]</span></span></p>
<p>This inverse relationship between velocity and the space charge force has real-life consequences. It tells us that space charge is important if 1) the beam is very intense, meaning there are many particles in a small area, or 2) the beam is very energetic, meaning it is moving extremely fast. For example, space charge can usually be ignored in electron beams, which move near the speed of light for very modest energies due to their tiny mass, but is significant in high-intensity, low-energy hadron accelerators such as <a href="https://frib.msu.edu">FRIB</a>, <a href="https://neutrons.ornl.gov/sns">SNS</a>, and <a href="https://europeanspallationsource.se">ESS</a>.</p>
<p>We should now address the difficulty in determining the evolution of this system: the force on a particle in an <span class="math inline">\(n\)</span>-particle bunch depends on the positions of the other <span class="math inline">\(n - 1\)</span> particles. The approach of statistical mechanics to this problem is to introduce a <em>distribution function</em> <span class="math inline">\(f(\mathbf{x}, \mathbf{x}', s)\)</span> which gives the particle density at axial position <span class="math inline">\(s\)</span> and phase space coordinates <span class="math inline">\(\mathbf{x}\)</span>, <span class="math inline">\(\mathbf{x}'\)</span>. The Vlasov-Poisson system of equations determines the evolution of <span class="math inline">\(f\)</span> as long as we ignore collisions between particles:</p>
<p><span id="eq-Vlasov"><span class="math display">\[
\frac{\partial{f}}{\partial{s}} +
\mathbf{x}'\cdot \frac{\partial{f}}{\partial{\mathbf{x}}} +
\mathbf{x}'' \cdot \frac{\partial{f}}{\partial{\mathbf{x}'}}
= 0.
\tag{3}\]</span></span></p>
<p>We know <span class="math inline">\(\mathbf{x''}\)</span> from <a href="#eq-EOM" class="quarto-xref">Equation&nbsp;1</a>. The electric field is obtained from Poisson’s equation:</p>
<p><span id="eq-Poisson"><span class="math display">\[
\nabla \cdot \mathbf{E} = -\nabla^2 \phi = \frac{\rho}{\varepsilon_0}.
\tag{4}\]</span></span></p>
<p>Finally, the transverse charge density <span class="math inline">\(\rho\)</span> is determined by</p>
<p><span id="eq-rho"><span class="math display">\[
\rho = q \int{f dx'dy'}.
\tag{5}\]</span></span></p>
<p>Although these equations are easy to write down, they are generally impossible to solve analytically. We need to turn to a computer for help.</p>
</section>
<section id="computational-method" class="level2">
<h2 class="anchored" data-anchor-id="computational-method">Computational method</h2>
<p>The Vlasov equation could be solved directly, but this is difficult, especially in 2D or 3D. On the other end of the spectrum, the notion of a fluid in phase space could be abandoned and each particle could be tracked individually, computing the forces using direct sums. But this is infeasible with current hardware; the time complexity would by <span class="math inline">\(O(n^2)\)</span>, where <span class="math inline">\(n\)</span> is the number of particles, and <span class="math inline">\(n\)</span> may be on the order of <span class="math inline">\(10^{14}\)</span>. The particle-in-cell (PIC) method is a sort of combination of these two approaches. The idea is to track a group of <em>macroparticles</em> according to <a href="#eq-EOM" class="quarto-xref">Equation&nbsp;1</a>, each of which represents a large number of real particles. The fields, however, are solved from <a href="#eq-Poisson" class="quarto-xref">Equation&nbsp;4</a>. The key step is transforming back and forth between a discrete and continuous representation of the bunch. The simulation loop for the PIC method is shown below.</p>
<p><br></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="pic_loop.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Fig. 4. The particle-in-cell (PIC) loop."><img src="pic_loop.png" class="img-fluid figure-img" style="width:77.0%" alt="Fig. 4. The particle-in-cell (PIC) loop."></a></p>
<figcaption>Fig. 4. The particle-in-cell (PIC) loop.</figcaption>
</figure>
</div>
<p><br></p>
<p>In the next sections I will discuss each of these steps and implement them in Python. The hidden cell below shows all the imports needed to run the code.</p>
<div id="cell-17" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Imports</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> Cython</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext cython</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> animation</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.lines <span class="im">import</span> Line2D</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.patches <span class="im">import</span> Ellipse</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> proplot <span class="im">as</span> pplt</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> fft2</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> ifft2</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> RegularGridInterpolator</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> odeint</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> truncnorm</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm.notebook <span class="im">import</span> trange </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s first create a <code>Bunch</code> class, which is a simple container for the bunch coordinates.</p>
<div id="cell-20" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Bunch:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Container for four-dimensional phase space distribution.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Attributes</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    intensity : float</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of physical particles in the bunch.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">    length : float</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Length of the bunch [m].</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">    mass, kin_energy : float</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Mass [GeV/c^2], charge [C], and kinetic energy [GeV] per particle.</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">    nparts : float</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of macroparticles in the bunch.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">    X : ndarray, shape (nparts, 4)</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Array of particle coordinates. Columns are [x, x', y, y']. Units are</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">        meters and radians.</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">    positions : ndarray, shape (nparts, 2):</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">        Just the x and y positions (for convenience).</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, intensity<span class="op">=</span><span class="fl">1e14</span>, length<span class="op">=</span><span class="fl">250.</span>, mass<span class="op">=</span><span class="fl">0.938</span>, kin_energy<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.intensity, <span class="va">self</span>.length <span class="op">=</span> intensity, length</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.mass, <span class="va">self</span>.kin_energy <span class="op">=</span> mass, kin_energy</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gamma <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> (kin_energy <span class="op">/</span> mass) <span class="co"># Lorentz factor</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta <span class="op">=</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> (<span class="dv">1</span> <span class="op">/</span> <span class="va">self</span>.gamma)<span class="op">**</span><span class="dv">2</span>) <span class="co"># v/c</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        r0 <span class="op">=</span> <span class="fl">1.53469e-18</span> <span class="co"># classical proton radius [m]</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.perveance <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> r0 <span class="op">*</span> intensity <span class="op">/</span> (length <span class="op">*</span> <span class="va">self</span>.beta<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>.gamma<span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nparts <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.compute_macrosize()</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.X, <span class="va">self</span>.positions <span class="op">=</span> <span class="va">None</span>, <span class="va">None</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_macrosize(<span class="va">self</span>):</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Update the macrosize and macrocharge."""</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.macrosize <span class="op">=</span> <span class="va">self</span>.intensity <span class="op">//</span> <span class="va">self</span>.nparts <span class="cf">if</span> <span class="va">self</span>.nparts <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                                </span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fill(<span class="va">self</span>, X):</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Fill with particles. X is the 4D phase space coordinate array."""</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.X <span class="op">=</span> X <span class="cf">if</span> <span class="va">self</span>.X <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span> np.vstack([<span class="va">self</span>.X, X])</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.positions <span class="op">=</span> <span class="va">self</span>.X[:, [<span class="dv">0</span>, <span class="dv">2</span>]]</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nparts <span class="op">=</span> <span class="va">self</span>.X.shape[<span class="dv">0</span>]</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.compute_macrosize()</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_extremum(<span class="va">self</span>):</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Get extreme x and y coorinates."""</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.xmin, <span class="va">self</span>.ymin <span class="op">=</span> np.<span class="bu">min</span>(<span class="va">self</span>.positions, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.xmax, <span class="va">self</span>.ymax <span class="op">=</span> np.<span class="bu">max</span>(<span class="va">self</span>.positions, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.xlim, <span class="va">self</span>.ylim <span class="op">=</span> (<span class="va">self</span>.xmin, <span class="va">self</span>.xmax), (<span class="va">self</span>.ymin, <span class="va">self</span>.ymax)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="weighting" class="level3">
<h3 class="anchored" data-anchor-id="weighting">Weighting</h3>
<p>Starting from a group of macroparticles, we need to produce a charge density <span class="math inline">\(\rho_{i,j}\)</span> on a grid. The most simple approach is the <em>nearest grid point (NGP)</em> method, which, as the name suggests, assigns the full particle charge to the closest grid point. This is commonly called <em>zero-order weighting</em>; although it is very fast and easy to implement, it is not commonly used because it can lead to significant noise. A better method called <em>cloud-in-cell (CIC)</em> treats each particle as a rectangular, uniform density cloud of charge with dimensions equal to the grid spacing. A fractional part of the charge is assigned based on the fraction of the cloud overlapping with a given cell. This can be thought of as <em>first-order weighting</em>. To get a sense of what these methods are doing (in 1D), we can slide a particle across a cell and plot the resulting density of the cell at each position, thus giving an effective particle shape.</p>
<div id="cell-23" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shape_func(u, v, cell_width, method<span class="op">=</span><span class="st">'NGP'</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    S, diff <span class="op">=</span> <span class="fl">0.0</span>, np.<span class="bu">abs</span>(u <span class="op">-</span> v)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> method.upper() <span class="op">==</span> <span class="st">'NGP'</span>:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        S <span class="op">=</span> <span class="fl">1.0</span> <span class="cf">if</span> diff <span class="op">&lt;</span> (<span class="fl">0.5</span> <span class="op">*</span> cell_width) <span class="cf">else</span> <span class="fl">0.0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> method.upper() <span class="op">==</span> <span class="st">'CIC'</span>:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        S <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> diff <span class="op">/</span> cell_width <span class="cf">if</span> diff <span class="op">&lt;</span> cell_width <span class="cf">else</span> <span class="fl">0.0</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S <span class="op">/</span> cell_width</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> pplt.subplots(figsize<span class="op">=</span>(<span class="fl">4.0</span>, <span class="fl">1.5</span>))</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>xvals <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="dv">1000</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, method <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="st">'NGP'</span>, <span class="st">'CIC'</span>]):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    densities <span class="op">=</span> [shape_func(x, <span class="fl">0.0</span>, <span class="fl">1.0</span>, method) <span class="cf">for</span> x <span class="kw">in</span> xvals]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    ax.plot(xvals, densities, color<span class="op">=</span><span class="st">'black'</span>, ls<span class="op">=</span>[<span class="st">'-'</span>, <span class="st">':'</span>][i], label<span class="op">=</span>method,)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">format</span>(ylim<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">1.1</span>), xlabel<span class="op">=</span><span class="st">'($x - x_k) \,/\, \Delta x$'</span>, ylabel<span class="op">=</span><span class="st">'Density'</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">'r'</span>, ncols<span class="op">=</span><span class="dv">1</span>, framealpha<span class="op">=</span><span class="fl">0.0</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="./_output_NGP_CIC.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Fig. 5. Effective particle shape for Nearest-grid-point (NGP) and cloud-in-cell (CIC) weighting."><img src="./_output_NGP_CIC.png" class="img-fluid figure-img" style="width:55.0%" alt="Fig. 5. Effective particle shape for Nearest-grid-point (NGP) and cloud-in-cell (CIC) weighting."></a></p>
<figcaption>Fig. 5. Effective particle shape for Nearest-grid-point (NGP) and cloud-in-cell (CIC) weighting.</figcaption>
</figure>
</div>
<p>The NGP method leads to a discontinuous boundary while the CIC method leads to a continous boundary (but discontinous derivative). There are also higher order methods which lead to a smooth boundary, but I don’t cover those here.</p>
<p>We also need to perform the inverse operation: given the electric field at each grid point, interpolate the value at each particle position. The same method applies here. NGP just uses the electric field at the nearest grid point, while CIC weights the four nearest grid points. The following <code>Grid</code> class implements the CIC method. Notice that <a href="https://cython.readthedocs.io/en/latest/src/userguide/numpy_tutorial.html">Cython</a> is used in the for-loop in the <code>distribute</code> method. I couldn’t figure out a way to perform this operation with the loop, and in pure Python it took about 90% of the runtime for a single simulation step. Using Cython gave a significant performance boost.</p>
<div id="cell-27" class="cell" data-scrolled="true" data-tags="[]" data-execution_count="6">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>cython</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> RegularGridInterpolator</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Grid:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Class for 2D grid.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Attributes</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">    xmin, ymin, xmax, ymax : float</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Minimum and maximum coordinates.</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Nx, Ny : int</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of grid points.</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">    dx, dy : int</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Spacing between grid points.</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co">    x, y : ndarray, shape (Nx,) or (Ny,)</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Positions of each grid point.</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co">    cell_area : float</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="co">        Area of each cell.</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, xlim<span class="op">=</span>(<span class="op">-</span><span class="fl">1.0</span>, <span class="fl">1.0</span>), ylim<span class="op">=</span>(<span class="op">-</span><span class="fl">1.0</span>, <span class="fl">1.0</span>), size<span class="op">=</span>(<span class="dv">64</span>, <span class="dv">64</span>)):</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.xlim <span class="op">=</span> xlim</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ylim <span class="op">=</span> ylim</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        (<span class="va">self</span>.xmin, <span class="va">self</span>.xmax) <span class="op">=</span> <span class="va">self</span>.xlim</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        (<span class="va">self</span>.ymin, <span class="va">self</span>.ymax) <span class="op">=</span> <span class="va">self</span>.ylim</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.size <span class="op">=</span> size</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        (<span class="va">self</span>.Nx, <span class="va">self</span>.Ny) <span class="op">=</span> size</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dx <span class="op">=</span> (<span class="va">self</span>.xmax <span class="op">-</span> <span class="va">self</span>.xmin) <span class="op">/</span> <span class="bu">float</span>(<span class="va">self</span>.Nx <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dy <span class="op">=</span> (<span class="va">self</span>.ymax <span class="op">-</span> <span class="va">self</span>.ymin) <span class="op">/</span> <span class="bu">float</span>(<span class="va">self</span>.Ny <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cell_area <span class="op">=</span> <span class="va">self</span>.dx <span class="op">*</span> <span class="va">self</span>.dy</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> np.linspace(<span class="va">self</span>.xmin, <span class="va">self</span>.xmax, <span class="va">self</span>.Nx)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> np.linspace(<span class="va">self</span>.ymin, <span class="va">self</span>.ymax, <span class="va">self</span>.Ny)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_lims(<span class="va">self</span>, xlim, ylim):</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Set the min and max grid coordinates."""</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.<span class="fu">__init__</span>(xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim, size<span class="op">=</span><span class="va">self</span>.size)</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> zeros(<span class="va">self</span>):</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Create array of zeros with same size as the grid."""</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.zeros((<span class="va">self</span>.size))</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> distribute(<span class="va">self</span>, positions):</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Distribute points on the grid using the cloud-in-cell (CIC) method.</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a><span class="co">        positions : ndarray, shape (n, 2)</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a><span class="co">            List of (x, y) positions.</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a><span class="co">            </span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a><span class="co">        rho : ndarray, shape (Nx, Ny)</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a><span class="co">            The value rho[i, j] gives the number of macroparticles in the i,j cell.</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute area overlapping with 4 nearest neighbors (A1, A2, A3, A4)</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>        ivals <span class="op">=</span> np.floor((positions[:, <span class="dv">0</span>] <span class="op">-</span> <span class="va">self</span>.xmin) <span class="op">/</span> <span class="va">self</span>.dx).astype(<span class="bu">int</span>)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>        jvals <span class="op">=</span> np.floor((positions[:, <span class="dv">1</span>] <span class="op">-</span> <span class="va">self</span>.ymin) <span class="op">/</span> <span class="va">self</span>.dy).astype(<span class="bu">int</span>)</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>        ivals[ivals <span class="op">&gt;</span> <span class="va">self</span>.Nx <span class="op">-</span> <span class="dv">2</span>] <span class="op">=</span> <span class="va">self</span>.Nx <span class="op">-</span> <span class="dv">2</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>        jvals[jvals <span class="op">&gt;</span> <span class="va">self</span>.Ny <span class="op">-</span> <span class="dv">2</span>] <span class="op">=</span> <span class="va">self</span>.Ny <span class="op">-</span> <span class="dv">2</span></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>        x_i, x_ip1 <span class="op">=</span> <span class="va">self</span>.x[ivals], <span class="va">self</span>.x[ivals <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>        y_j, y_jp1 <span class="op">=</span> <span class="va">self</span>.y[jvals], <span class="va">self</span>.y[jvals <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>        _A1 <span class="op">=</span> (positions[:, <span class="dv">0</span>] <span class="op">-</span> x_i) <span class="op">*</span> (positions[:, <span class="dv">1</span>] <span class="op">-</span> y_j)</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>        _A2 <span class="op">=</span> (x_ip1 <span class="op">-</span> positions[:, <span class="dv">0</span>]) <span class="op">*</span> (positions[:, <span class="dv">1</span>] <span class="op">-</span> y_j)</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>        _A3 <span class="op">=</span> (positions[:, <span class="dv">0</span>] <span class="op">-</span> x_i) <span class="op">*</span> (y_jp1 <span class="op">-</span> positions[:, <span class="dv">1</span>])</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>        _A4 <span class="op">=</span> (x_ip1 <span class="op">-</span> positions[:, <span class="dv">0</span>]) <span class="op">*</span> (y_jp1 <span class="op">-</span> positions[:, <span class="dv">1</span>])</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Distribute fractional areas</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>        rho <span class="op">=</span> <span class="va">self</span>.zeros()</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>        cdef double[:, :] rho_view <span class="op">=</span> rho </span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>        cdef <span class="bu">int</span> i, j</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, j, A1, A2, A3, A4 <span class="kw">in</span> <span class="bu">zip</span>(ivals, jvals, _A1, _A2, _A3, _A4):</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>            rho_view[i, j] <span class="op">+=</span> A4</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>            rho_view[i <span class="op">+</span> <span class="dv">1</span>, j] <span class="op">+=</span> A3</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>            rho_view[i, j <span class="op">+</span> <span class="dv">1</span>] <span class="op">+=</span> A2</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>            rho_view[i <span class="op">+</span> <span class="dv">1</span>, j <span class="op">+</span> <span class="dv">1</span>] <span class="op">+=</span> A1      </span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rho <span class="op">/</span> <span class="va">self</span>.cell_area</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> interpolate(<span class="va">self</span>, grid_vals, positions):</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Interpolate values from the grid using the CIC method.</span></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a><span class="co">        positions : ndarray, shape (n, 2)</span></span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a><span class="co">            List of (x, y) positions.</span></span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a><span class="co">        grid_vals : ndarray, shape (n, 2)</span></span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a><span class="co">            Scalar value at each coordinate point.</span></span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a><span class="co">            </span></span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a><span class="co">        int_vals : ndarray, shape (nparts,)</span></span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a><span class="co">            Interpolated value at each position.</span></span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>        int_func <span class="op">=</span> RegularGridInterpolator((<span class="va">self</span>.x, <span class="va">self</span>.y), grid_vals)</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> int_func(positions)</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gradient(<span class="va">self</span>, grid_vals):</span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute gradient using 2nd order centered differencing.</span></span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a><span class="co">        grid_vals : ndarray, shape (Nx, Ny)</span></span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a><span class="co">            Scalar values at each grid point.</span></span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a><span class="co">            </span></span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a><span class="co">        gradx, grady : ndarray, shape (Nx, Ny)</span></span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a><span class="co">            The x and y gradient at each grid point.</span></span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.gradient(grid_vals, <span class="va">self</span>.dx, <span class="va">self</span>.dy)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It should also be mentioned that the field interpolation method should be the same as the charge deposition method; if this is not true, it is possible for a particle to exert a force on itself! Let’s test the method with a <span class="math inline">\(64 \times 64\)</span> grid.</p>
<div id="cell-29" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a 2D bunch.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">1</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>n_parts <span class="op">=</span> <span class="dv">100000</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>_X <span class="op">=</span> np.random.normal(scale<span class="op">=</span><span class="fl">1.0</span>, size<span class="op">=</span>(n_parts, <span class="dv">2</span>))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>n_clusters <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_clusters):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    loc <span class="op">=</span> np.random.uniform(<span class="op">-</span><span class="fl">2.0</span>, <span class="fl">2.0</span>, size<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    scale <span class="op">=</span> np.random.uniform(<span class="fl">0.5</span>, <span class="fl">1.5</span>, size<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    _X <span class="op">=</span> np.vstack([_X, np.random.normal(loc<span class="op">=</span>loc, scale<span class="op">=</span>scale, size<span class="op">=</span>(n_parts, <span class="dv">2</span>))])</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>_X <span class="op">=</span> _X <span class="op">-</span> np.mean(_X)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>idx, <span class="op">=</span> np.where(np.sqrt(_X[:, <span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> _X[:, <span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>) <span class="op">&lt;</span> <span class="fl">5.0</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>_X <span class="op">=</span> _X[idx, :]</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>_X <span class="op">=</span> _X <span class="op">-</span> np.mean(_X)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.zeros((_X.shape[<span class="dv">0</span>], <span class="dv">4</span>))</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>X[:, (<span class="dv">0</span>, <span class="dv">2</span>)] <span class="op">=</span> _X</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>bunch <span class="op">=</span> Bunch()</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>bunch.fill(X)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>bunch.compute_extremum()</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribute the particles on an x-y grid.</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>n_bins <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> Grid(bunch.xlim, bunch.ylim, size<span class="op">=</span>(n_bins, n_bins))</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> grid.distribute(bunch.positions) </span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> pplt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, figwidth<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>axs.<span class="bu">format</span>(xlabel<span class="op">=</span><span class="st">'x [mm]'</span>, ylabel<span class="op">=</span><span class="st">'y [mm]'</span>)</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>n_samp <span class="op">=</span> <span class="dv">2000</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> np.random.choice(X.shape[<span class="dv">0</span>], n_samp, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>X_samp <span class="op">=</span> X[idx, :]</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].scatter(X_samp[:, <span class="dv">0</span>], X_samp[:, <span class="dv">2</span>], s<span class="op">=</span><span class="dv">1</span>, c<span class="op">=</span><span class="st">'w'</span>, ec<span class="op">=</span><span class="st">'None'</span>)</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_facecolor(<span class="st">'k'</span>)</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].pcolormesh(grid.x, grid.y, rho.T, cmap<span class="op">=</span><span class="st">'mono_r'</span>)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>axs.<span class="bu">format</span>(xlim<span class="op">=</span>grid.xlim, ylim<span class="op">=</span>grid.ylim)</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].<span class="bu">format</span>(title<span class="op">=</span><span class="ss">f'</span><span class="sc">{</span>n_samp<span class="sc">}</span><span class="ss"> random samples'</span>)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].<span class="bu">format</span>(title<span class="op">=</span><span class="st">'CIC weighting'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="index_files/figure-html/cell-8-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Fig. 6. Test of cloud-in-cell (CIC) particle weighting on a regular 64 x 64 grid."><img src="index_files/figure-html/cell-8-output-1.png" width="700" height="382" alt="Fig. 6. Test of cloud-in-cell (CIC) particle weighting on a regular 64 x 64 grid." class="figure-img"></a></p>
<figcaption>Fig. 6. Test of cloud-in-cell (CIC) particle weighting on a regular 64 x 64 grid.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="field-solver" class="level3">
<h3 class="anchored" data-anchor-id="field-solver">Field solver</h3>
<p>The workhorse in the simulation loop is the field solver. We need to solve Poisson’s equation:</p>
<p><span id="eq-label"><span class="math display">\[
\left({\frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}}\right) = -\frac{\rho\left(x, y\right)}{\varepsilon_0}.
\tag{6}\]</span></span></p>
<p>The discretized version of the equation reads</p>
<p><span id="eq-label"><span class="math display">\[
\frac{\phi_{i+1,j} -2\phi_{i,j} +\phi_{i-1,j}}{{\Delta_x}^2} + \frac{\phi_{i,j+1} -2\phi_{i,j} + \phi_{i,j-1}}{{\Delta_y}^2} = -\frac{\rho_{i,j}}{\varepsilon_0}
\tag{7}\]</span></span></p>
<p>for a grid with spacing <span class="math inline">\(\Delta_x\)</span> and <span class="math inline">\(\Delta_y\)</span>. There are multiple paths to a solution; we will focus on the method implemented in PyORBIT which utilizes the Fourier convolution theorem. Let’s briefly go over this method. The potential from an infinite line of elementary charges at the origin with number density <span class="math inline">\(\lambda\)</span> is</p>
<p><span id="eq-label"><span class="math display">\[
\phi(\mathbf{x}) = -\frac{\lambda e}{2\pi\varepsilon_0} \ln{|\mathbf{x}|} = -\frac{\lambda e}{2\pi\varepsilon_0} \int{\ln{|\mathbf{x} - \mathbf{y}|}\delta(\mathbf{y})d\mathbf{y}}.
\tag{8}\]</span></span></p>
<p>Note that <span class="math inline">\(\mathbf{y}\)</span> is just a dummy variable. By letting <span class="math inline">\(G(\mathbf{x} - \mathbf{y}) = -\ln{|\mathbf{x} - \mathbf{y}|}\)</span> and <span class="math inline">\(\rho(\mathbf{x}) = \delta(\mathbf{x})\)</span>, then up to a scaling factor we have</p>
<p><span id="eq-label"><span class="math display">\[
\phi(\mathbf{x}) = \int{G(\mathbf{x} - \mathbf{y})\rho(\mathbf{y})d\mathbf{y}} = G(\mathbf{x}) * \rho(\mathbf{x}).
\tag{9}\]</span></span></p>
<p>In this form the potential is a <a href="https://en.wikipedia.org/wiki/Convolution">convolution</a> (represented by <span class="math inline">\(*\)</span>) of the charge density <span class="math inline">\(\rho\)</span> with <span class="math inline">\(G\)</span>, which is called the <a href="https://en.wikipedia.org/wiki/Green%27s_function">Green’s function</a>. On the grid this will look like</p>
<p><span id="eq-Poisson_Green"><span class="math display">\[
\phi_{i, j} = \sum_{k,l \ne i,j}{G_{i-k, j-l} \rho_{k, l}}.
\tag{10}\]</span></span></p>
<p>This solves the problem in <span class="math inline">\(O(N^2)\)</span> time complexity for <span class="math inline">\(N\)</span> grid points. This is already much faster than a direct force calculation but could still get expensive for fine grids. We can speed things up by exploiting the <a href="https://en.wikipedia.org/wiki/Convolution_theorem">convolution theorem</a>, which says that the Fourier transform of a convolution of two functions is equal to the product of their Fourier transforms. The Fourier transform is defined by</p>
<p><span id="eq-label"><span class="math display">\[
\hat{\phi}(\mathbf{k})= \mathcal{F}\left[\phi(\mathbf{x})\right] = \int_{-\infty}^{\infty}{e^{-i\mathbf{k}\cdot\mathbf{x}} \phi(\mathbf{x}) d\mathbf{x}}.
\tag{11}\]</span></span></p>
<p>The convolution theorem then says <span id="eq-label"><span class="math display">\[
\mathcal{F}\left[\rho * G\right] = \mathcal{F}\left[\rho\right] \cdot \mathcal{F}\left[G\right].
\tag{12}\]</span></span></p>
<p>For the discrete equation this gives</p>
<p><span id="eq-label"><span class="math display">\[
\hat{\phi}_{n, m} = \hat{\rho}_{n, m} \hat{G}_{n, m},
\tag{13}\]</span></span></p>
<p>where the hat represents the discrete Fourier transform. The time complexity can be reduced to <span class="math inline">\(O\left(N \log N\right)\)</span> with the <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">FFT</a> algorithm at our disposal.</p>
<p>There is a caveat to this method: <a href="#eq-Poisson_Green" class="quarto-xref">Equation&nbsp;10</a> must be a circular convolution in order to use the FFT algorithm, which means <span class="math inline">\(G\)</span> must be periodic. But the beam is in free space (we’ve neglected any conducting boundary), so this is not true. We can make it true by doubling the grid size in each dimension. We then make <span class="math inline">\(G\)</span> a mirror reflection in the new quadrants so that it is periodic, and also set the charge density equal to zero in these regions. After running the method on this larger grid, the potential in the new quadrants will be unphysical; however, the potential in the original quadrant will be correct. There are also some tricks we can play to reduce the space complexity, and in the end doubling the grid size is not much of a price to pay for the gain in speed. The method is implemented in the <code>PoissonSolver</code> class.</p>
<div id="cell-35" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PoissonSolver:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Class to solve Poisson's equation on a 2D grid.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Attributes</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    rho, phi, G : ndarray, shape (2*Nx, 2*Ny)</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">        The density (rho), potential (phi), and Green's function (G) at each</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">        grid point on a doubled grid. Only one quadrant (i &lt; Nx, j &lt; Ny)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">        corresponds to to the real potential.</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, grid, sign<span class="op">=-</span><span class="fl">1.0</span>):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.grid <span class="op">=</span> grid</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        new_shape <span class="op">=</span> (<span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>.grid.Nx, <span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>.grid.Ny)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.rho <span class="op">=</span> np.zeros(new_shape)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.G <span class="op">=</span> np.zeros(new_shape)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.phi <span class="op">=</span> np.zeros(new_shape)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_grid(<span class="va">self</span>, grid):</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.<span class="fu">__init__</span>(grid)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_greens_function(<span class="va">self</span>):</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute Green's function on doubled grid."""</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        Nx, Ny <span class="op">=</span> <span class="va">self</span>.grid.Nx, <span class="va">self</span>.grid.Ny</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        Y, X <span class="op">=</span> np.meshgrid(<span class="va">self</span>.grid.x <span class="op">-</span> <span class="va">self</span>.grid.xmin, <span class="va">self</span>.grid.y <span class="op">-</span> <span class="va">self</span>.grid.ymin)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.G[:Nx, :Ny] <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> np.log(X<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> Y<span class="op">**</span><span class="dv">2</span>, out<span class="op">=</span>np.zeros_like(X), </span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>                                         where<span class="op">=</span>(X <span class="op">+</span> Y <span class="op">&gt;</span> <span class="dv">0</span>))</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.G[Nx:, :] <span class="op">=</span> np.flip(<span class="va">self</span>.G[:Nx, :], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.G[:, Ny:] <span class="op">=</span> np.flip(<span class="va">self</span>.G[:, :Ny], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_potential(<span class="va">self</span>, rho):</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute the scaled electric potential on the grid.</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="co">        rho : ndarray, shape (Nx, Ny)</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="co">            Number of macroparticles at each grid point.</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="co">        phi : ndarray, shape (Nx, Ny)</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a><span class="co">            Scaled electric potential at each grid point.</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>        Nx, Ny <span class="op">=</span> <span class="va">self</span>.grid.Nx, <span class="va">self</span>.grid.Ny</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.rho[:Nx, :Ny] <span class="op">=</span> rho</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.compute_greens_function()</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.phi <span class="op">=</span> ifft2(fft2(<span class="va">self</span>.G) <span class="op">*</span> fft2(<span class="va">self</span>.rho)).real</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.phi[:Nx, :Ny]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Running the algorithm gives the following potential on the doubled grid:</p>
<div id="cell-37" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>solver <span class="op">=</span> PoissonSolver(grid)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>phi <span class="op">=</span> solver.get_potential(rho)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> pplt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, figwidth<span class="op">=</span><span class="fl">8.0</span>, share<span class="op">=</span><span class="va">False</span>, space<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].pcolormesh(solver.rho.T, cmap<span class="op">=</span><span class="st">'mono_r'</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].pcolormesh(solver.phi.T, cmap<span class="op">=</span><span class="st">'mono_r'</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> axs:</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    ax.axvline(grid.Nx <span class="op">-</span> <span class="fl">0.5</span>, c<span class="op">=</span><span class="st">'w'</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    ax.axhline(grid.Ny <span class="op">-</span> <span class="fl">0.5</span>, c<span class="op">=</span><span class="st">'w'</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> xy <span class="kw">in</span> [(<span class="fl">0.65</span>, <span class="fl">0.75</span>), (<span class="fl">0.15</span>, <span class="fl">0.75</span>), (<span class="fl">0.65</span>, <span class="fl">0.25</span>)]:</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        ax.annotate(<span class="st">'unphysical'</span>, xy<span class="op">=</span>xy, xycoords<span class="op">=</span><span class="st">'axes fraction'</span>, c<span class="op">=</span><span class="st">'w'</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].<span class="bu">format</span>(title<span class="op">=</span><span class="vs">r'Density $\rho$'</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].<span class="bu">format</span>(title<span class="op">=</span><span class="vs">r'Potential $\phi$'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="index_files/figure-html/cell-10-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Fig. 7. Electric potential on doubled grid."><img src="index_files/figure-html/cell-10-output-1.png" width="800" height="400" alt="Fig. 7. Electric potential on doubled grid." class="figure-img"></a></p>
<figcaption>Fig. 7. Electric potential on doubled grid.</figcaption>
</figure>
</div>
</div>
</div>
<p>We can then approximate the gradient of the potential using second-order centered differencing. This gives</p>
<p><span class="math display">\[(\nabla\phi)_{i,j} = \frac{\phi_{i+1,j} - \phi_{i-1,j}}{2\Delta_x} \hat{x} + \frac{\phi_{i,j+1} - \phi_{i,j-1}}{2\Delta_y} \hat{y}. \tag{15}\]</span></p>
<p>The following plot shows the electric field at each position.</p>
<div id="cell-40" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>Ex, Ey <span class="op">=</span> grid.gradient(<span class="op">-</span>phi)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> pplt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, figwidth<span class="op">=</span><span class="fl">7.5</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, E <span class="kw">in</span> <span class="bu">zip</span>(axs, [Ex, Ey]):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> ax.pcolormesh(</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        grid.x, grid.y, E.T <span class="op">/</span> np.<span class="bu">max</span>(E), shading<span class="op">=</span><span class="st">'auto'</span>, </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        vmin<span class="op">=-</span><span class="fl">1.0</span>, vmax<span class="op">=</span><span class="fl">1.0</span>, cmap<span class="op">=</span><span class="st">'RdBu'</span>,</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>fig.colorbar(m, width<span class="op">=</span><span class="st">'1.25em'</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>axs.<span class="bu">format</span>(xlabel<span class="op">=</span><span class="st">'x'</span>, ylabel<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].<span class="bu">format</span>(title<span class="op">=</span><span class="vs">r'$E_x$ / max($E_x$)'</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].<span class="bu">format</span>(title<span class="op">=</span><span class="vs">r'$E_y$ / max($E_y$)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="index_files/figure-html/cell-11-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Fig. 8. Electric field on original grid."><img src="index_files/figure-html/cell-11-output-1.png" width="750" height="376" alt="Fig. 8. Electric field on original grid." class="figure-img"></a></p>
<figcaption>Fig. 8. Electric field on original grid.</figcaption>
</figure>
</div>
</div>
</div>
<p>Finally, the value of the electric field at each particle position can be interpolated from the grid.</p>
<div id="cell-42" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Ex_int <span class="op">=</span> grid.interpolate(Ex, bunch.positions)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>Ey_int <span class="op">=</span> grid.interpolate(Ey, bunch.positions)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="particle-mover" class="level3">
<h3 class="anchored" data-anchor-id="particle-mover">Particle mover</h3>
<p>All we need to do in this step is integrate the equations of motion. A common method is <a href="https://en.wikipedia.org/wiki/Leapfrog_integration">leapfrog integration</a> in which the position and velocity are integrated out of phase as follows:</p>
<p><span id="eq-label"><span class="math display">\[
m \left(\frac{\mathbf{v}_{i+1/2} - \mathbf{v}_{i-1/2}}{\Delta_t}\right) = \mathbf{F}(\mathbf{x}_i),
\tag{14}\]</span></span></p>
<p><span id="eq-label"><span class="math display">\[
\frac{\mathbf{x}_{i+1} - \mathbf{x}_i}{\Delta_t} = \mathbf{v}_{i+1/2}
\tag{15}\]</span></span></p>
<p><br></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="leapfrog.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Fig. 9. Leapfrog integration. (Source: S. Lund.)"><img src="leapfrog.png" class="img-fluid figure-img" style="width:75.0%" alt="Fig. 9. Leapfrog integration. (Source: S. Lund.)"></a></p>
<figcaption>Fig. 9. Leapfrog integration. (Source: S. Lund.)</figcaption>
</figure>
</div>
<p>A different scheme must be used when velocity-dependent forces are present. This is a symplectic integrator, which means it conserves energy. It is also second-order accurate, meaning that its error is proportional to the square of the <span class="math inline">\(\Delta_t\)</span>. Finally, it is time-reversible. The only complication is that, because the velocity and position are out of phase, we need to push the velocity back one half-step before starting the simulation, and push it one half-step forward when taking a measurement.</p>
</section>
</section>
<section id="putting-it-all-together" class="level2">
<h2 class="anchored" data-anchor-id="putting-it-all-together">Putting it all together</h2>
<section id="simulation-loop" class="level3">
<h3 class="anchored" data-anchor-id="simulation-loop">Simulation loop</h3>
<p>We have all the tools to implement the simulation loop. While <span class="math inline">\(s &lt; s_{max}\)</span> we:</p>
<ol type="1">
<li>Compute the charge density on the grid.</li>
<li>Find the electric potential on the grid.</li>
<li>Interpolate the electric field at the particle positions.</li>
<li>Update the particle positions.</li>
</ol>
<p>We’ll first create a <code>History</code> class which stores the beam moments or phase space coordinates.</p>
<div id="cell-51" class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> History:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Class to store bunch data over time.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Atributes</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">    ---------</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">    moments : list</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">        Second-order bunch moments. Each element is ndarray of shape (10,).</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">    coords : list</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Bunch coordinate arrays. Each element is ndarray of shape (nparts, 4)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">    moment_positions, coord_positions : list</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Positions corresponding to each element of `moments` or `coords`.</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, bunch, samples<span class="op">=</span><span class="st">'all'</span>):</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.X <span class="op">=</span> bunch.X</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.moments, <span class="va">self</span>.coords <span class="op">=</span> [], []</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.moment_positions, <span class="va">self</span>.coord_positions <span class="op">=</span> [], []</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> samples <span class="op">==</span> <span class="st">'all'</span> <span class="kw">or</span> samples <span class="op">&gt;=</span> bunch.nparts:</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.idx <span class="op">=</span> np.arange(bunch.nparts)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.idx <span class="op">=</span> np.random.choice(bunch.nparts, samples, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store_moments(<span class="va">self</span>, s):</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        Sigma <span class="op">=</span> np.cov(<span class="va">self</span>.X.T)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.moments.append(Sigma[np.triu_indices(<span class="dv">4</span>)])</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.moment_positions.append(s)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store_coords(<span class="va">self</span>, s):</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.coords.append(np.copy(<span class="va">self</span>.X[<span class="va">self</span>.idx, :]))</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.coord_positions.append(s)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> package(<span class="va">self</span>):</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.moments <span class="op">=</span> np.array(<span class="va">self</span>.moments)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.coords <span class="op">=</span> np.array(<span class="va">self</span>.coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we’ll create a <code>Simulation</code> class.</p>
<div id="cell-53" class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Simulation:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Class to simulate the evolution of a charged particle bunch in free space.</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Attributes</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">    bunch : Bunch:</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">        The bunch to track.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">    distance : float</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Total tracking distance [m].</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">    step_size : float</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Distance between force calculations [m].</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">    nsteps : float</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Total number of steps = int(length / ds).</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co">    steps_performed : int</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of steps performed so far.</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="co">    s : float</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Current bunch position.</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="co">    history : History object</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="co">        Object storing historic bunch data.</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co">    meas_every : dict</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="co">        Dictionary with keys: 'moments' and 'coords'. Values correspond to the </span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="co">        number of simulations steps between storing these quantities. For</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co">        example, `meas_every = {'coords':4, 'moments':2}` will store the</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="co">        moments every 4 steps and the moments every other step. Defaults to</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="co">        storing only the initial and final positions.</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="co">    samples : int</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of bunch particles to store when measuring phase space</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="co">        coordinates. Defaults to the entire coordinate array.</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, bunch, distance, step_size, grid_size, meas_every<span class="op">=</span>{}, </span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>                 samples<span class="op">=</span><span class="st">'all'</span>):</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bunch <span class="op">=</span> bunch</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.distance, <span class="va">self</span>.step_size <span class="op">=</span> distance, step_size </span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nsteps <span class="op">=</span> <span class="bu">int</span>(distance <span class="op">/</span> step_size)</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.grid <span class="op">=</span> Grid(size<span class="op">=</span>grid_size)</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.solver <span class="op">=</span> PoissonSolver(<span class="va">self</span>.grid)</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fields <span class="op">=</span> np.zeros((bunch.nparts, <span class="dv">2</span>))</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.history <span class="op">=</span> History(bunch, samples)  </span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.s, <span class="va">self</span>.steps_performed <span class="op">=</span> <span class="fl">0.0</span>, <span class="dv">0</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.meas_every <span class="op">=</span> meas_every</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.meas_every.setdefault(<span class="st">'moments'</span>, <span class="va">self</span>.nsteps)</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.meas_every.setdefault(<span class="st">'coords'</span>, <span class="va">self</span>.nsteps)</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sc_factor <span class="op">=</span> bunch.perveance <span class="op">/</span> bunch.nparts</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_grid(<span class="va">self</span>):</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Set grid limits from bunch size."""</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bunch.compute_extremum()</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.grid.set_lims(<span class="va">self</span>.bunch.xlim, <span class="va">self</span>.bunch.ylim)</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.solver.set_grid(<span class="va">self</span>.grid)</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_electric_field(<span class="va">self</span>):</span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute self-generated electric field."""</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.set_grid()</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>        rho <span class="op">=</span> <span class="va">self</span>.grid.distribute(<span class="va">self</span>.bunch.positions)</span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>        phi <span class="op">=</span> <span class="va">self</span>.solver.get_potential(rho)</span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>        Ex, Ey <span class="op">=</span> <span class="va">self</span>.grid.gradient(<span class="op">-</span>phi)</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fields[:, <span class="dv">0</span>] <span class="op">=</span> <span class="va">self</span>.grid.interpolate(Ex, <span class="va">self</span>.bunch.positions)</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fields[:, <span class="dv">1</span>] <span class="op">=</span> <span class="va">self</span>.grid.interpolate(Ey, <span class="va">self</span>.bunch.positions)</span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>                            </span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> kick(<span class="va">self</span>, step_size):</span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Update particle slopes."""</span></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bunch.X[:, <span class="dv">1</span>] <span class="op">+=</span> <span class="va">self</span>.sc_factor <span class="op">*</span> <span class="va">self</span>.fields[:, <span class="dv">0</span>] <span class="op">*</span> step_size</span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bunch.X[:, <span class="dv">3</span>] <span class="op">+=</span> <span class="va">self</span>.sc_factor <span class="op">*</span> <span class="va">self</span>.fields[:, <span class="dv">1</span>] <span class="op">*</span> step_size</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> push(<span class="va">self</span>, step_size):</span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Update particle positions."""</span></span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bunch.X[:, <span class="dv">0</span>] <span class="op">+=</span> <span class="va">self</span>.bunch.X[:, <span class="dv">1</span>] <span class="op">*</span> step_size</span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bunch.X[:, <span class="dv">2</span>] <span class="op">+=</span> <span class="va">self</span>.bunch.X[:, <span class="dv">3</span>] <span class="op">*</span> step_size</span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store(<span class="va">self</span>):</span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Store bunch data."""</span></span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a>        store_moments <span class="op">=</span> <span class="va">self</span>.steps_performed <span class="op">%</span> <span class="va">self</span>.meas_every[<span class="st">'moments'</span>] <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>        store_coords <span class="op">=</span> <span class="va">self</span>.steps_performed <span class="op">%</span> <span class="va">self</span>.meas_every[<span class="st">'coords'</span>] <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> (store_moments <span class="kw">or</span> store_coords):</span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a>        Xp <span class="op">=</span> np.copy(<span class="va">self</span>.bunch.X[:, [<span class="dv">1</span>, <span class="dv">3</span>]])</span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.kick(<span class="op">+</span><span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.step_size) <span class="co"># sync positions/slopes</span></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> store_moments:</span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.history.store_moments(<span class="va">self</span>.s)</span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> store_coords:</span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.history.store_coords(<span class="va">self</span>.s)</span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bunch.X[:, [<span class="dv">1</span>, <span class="dv">3</span>]] <span class="op">=</span> Xp</span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run(<span class="va">self</span>, meas_every<span class="op">=</span>{}):</span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Run the simulation."""</span></span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.store()</span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.compute_electric_field()</span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.kick(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.step_size) <span class="co"># desync positions/slopes</span></span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> trange(<span class="va">self</span>.nsteps):</span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.compute_electric_field()</span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.kick(<span class="va">self</span>.step_size)</span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.push(<span class="va">self</span>.step_size)</span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.s <span class="op">+=</span> <span class="va">self</span>.step_size</span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.steps_performed <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.store()</span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.history.package()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="benchmark-freely-expanding-vlasov-equilibrium-distribution" class="level3">
<h3 class="anchored" data-anchor-id="benchmark-freely-expanding-vlasov-equilibrium-distribution">Benchmark: freely expanding Vlasov equilibrium distribution</h3>
<p>We need some way of checking our method’s accuracy. Luckily there is an analytic benchmark available: the Kapchinskij-Vladimirskij (KV) distribution. Without going into any detail, the beam projects to a uniform density ellipse in the <span class="math inline">\(x\)</span>-<span class="math inline">\(y\)</span> plane, and the space charge forces produced within this ellipse are <em>linear</em> (in general space charge forces are nonlinear). If we plug the KV distribution into the Vlasov equation, it can be seen that these forces will remain linear for all time if the external focusing forces are also linear. As a consequence, a set of self-consistent differential equations describing the evolution of the ellipse boundary can be written down. If we consider the beam to be an upright ellipse with semi-axis <span class="math inline">\(a\)</span> along the <span class="math inline">\(x\)</span> axis and <span class="math inline">\(b\)</span> along the <span class="math inline">\(y\)</span> axis, then without external fields the equations read:</p>
<p><span class="math display">\[ a'' = \frac{2Q}{a + b} + \frac{\varepsilon_x}{a^3}, \]</span> <span class="math display">\[ b'' = \frac{2Q}{a + b} + \frac{\varepsilon_y}{b^3}. \tag{18}\]</span></p>
<p>These are known as the <em>KV envelope equations</em> or simply <em>envelope equations</em>. <span class="math inline">\(Q\)</span>, called the <em>perveance</em>, is a dimensionless number which is proportional to the beam intensity but reduced by the beam energy. We can think of this constant as a measure of the space charge strength. The <span class="math inline">\(\varepsilon_x\)</span> and <span class="math inline">\(\varepsilon_y\)</span> terms are called the <em>emittances</em> and determine the area occupied by the beam in <span class="math inline">\(x\)</span>-<span class="math inline">\(x'\)</span> and <span class="math inline">\(y\)</span>-<span class="math inline">\(y'\)</span> phase space. For example, a beam with all particles sitting perfectly still in the <span class="math inline">\(x\)</span>-<span class="math inline">\(y\)</span> plane has no emittance, but a beam which is instead spreading out has a nonzero emittance. These emittances will also be conserved for the KV distribution. The following function integrates the envelope equations.</p>
<div id="cell-57" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> track_env(X, positions, perveance<span class="op">=</span><span class="fl">0.0</span>):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Track beam moments (assuming KV distribution) through free space.</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">    X : ndarray, shape (nparts, 4)</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">        Transverse bunch coordinate array.</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">    positions : list</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">        List of positions at which to evaluate the equations.</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">    perveance : float</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">        The dimensionless space charge perveance.</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">    ndarray, shape (len(positions), 4)</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Each row gives [a, a', b, b'], where a and b are the beam</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">        radii in the x and y dimension, respectively.</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    Sigma <span class="op">=</span> np.cov(X.T)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> np.sqrt(Sigma[<span class="dv">0</span>, <span class="dv">0</span>]), np.sqrt(Sigma[<span class="dv">2</span>, <span class="dv">2</span>])</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    ap, bp <span class="op">=</span> Sigma[<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">/</span> a, Sigma[<span class="dv">2</span>, <span class="dv">3</span>] <span class="op">/</span> b</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    epsx <span class="op">=</span> np.sqrt(np.linalg.det(Sigma[:<span class="dv">2</span>, :<span class="dv">2</span>]))</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    epsy <span class="op">=</span> np.sqrt(np.linalg.det(Sigma[<span class="dv">2</span>:, <span class="dv">2</span>:]))</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> derivs(env, s):</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        a, ap, b, bp <span class="op">=</span> env</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        envp <span class="op">=</span> np.zeros(<span class="dv">4</span>)</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>        envp[<span class="dv">0</span>], envp[<span class="dv">2</span>] <span class="op">=</span> ap, bp</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>        envp[<span class="dv">1</span>] <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> perveance<span class="op">/</span>(a <span class="op">+</span> b) <span class="op">+</span> epsx<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> a<span class="op">**</span><span class="dv">3</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>        envp[<span class="dv">3</span>] <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> perveance<span class="op">/</span>(a <span class="op">+</span> b) <span class="op">+</span> epsy<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> b<span class="op">**</span><span class="dv">3</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> envp</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> odeint(derivs, [a, ap, b, bp], positions, atol<span class="op">=</span><span class="fl">1e-14</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Some care must be taken in the choice of simulation parameters; we need a fine enough grid to resolve the hard edge of the beam and enough macroparticles per grid cell to collect good statistics. I chose what I thought was reasonable: 128,000 macroparticles, a step size of 2.5 cm, and a <span class="math inline">\(128 \times 128\)</span> grid. Let’s create and track four identical KV distributions, each with a different intensity.</p>
<div id="cell-59" class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Bunch parameters</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>nparts <span class="op">=</span> <span class="dv">128000</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>bunch_length <span class="op">=</span> <span class="fl">250.0</span> <span class="co"># [m]</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>intensities <span class="op">=</span> [<span class="fl">0.0</span>, <span class="fl">10.0e14</span>, <span class="fl">20.0e14</span>, <span class="fl">40.0e14</span>]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>distance <span class="op">=</span> <span class="fl">10.0</span> <span class="co"># [m]</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>step_size <span class="op">=</span> <span class="fl">0.025</span> <span class="co"># [m]</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>grid_size <span class="op">=</span> (<span class="dv">128</span>, <span class="dv">128</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>meas_every <span class="op">=</span> {</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'moments'</span>: <span class="bu">int</span>(<span class="fl">0.1</span> <span class="op">*</span> distance <span class="op">/</span> step_size), </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'coords'</span>: <span class="dv">4</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Create KV bunch in normalized coordinates (surface of 4D unit sphere)</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.random.normal(size<span class="op">=</span>(nparts, <span class="dv">4</span>))</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.apply_along_axis(<span class="kw">lambda</span> row: row <span class="op">/</span> np.linalg.norm(row), <span class="dv">1</span>, X)</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Scale by emittance</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>eps_x, eps_y <span class="op">=</span> <span class="fl">10e-6</span>, <span class="fl">10e-6</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.sqrt(np.diag([eps_x, eps_x, eps_y, eps_y]))</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.apply_along_axis(<span class="kw">lambda</span> row: np.matmul(A, row), <span class="dv">1</span>, X)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Scale beam size and divergence relative to emittance</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>alpha_x <span class="op">=</span> alpha_y <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>beta_x <span class="op">=</span> beta_y <span class="op">=</span> <span class="fl">20.0</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> np.zeros((<span class="dv">4</span>, <span class="dv">4</span>))</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>V[:<span class="dv">2</span>, :<span class="dv">2</span>] <span class="op">=</span> np.sqrt(<span class="fl">1.0</span> <span class="op">/</span> beta_x)<span class="op">*</span> np.array([[beta_x, <span class="fl">0.0</span>], [alpha_x, <span class="fl">1.0</span>]])</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>V[<span class="dv">2</span>:, <span class="dv">2</span>:] <span class="op">=</span> np.sqrt(<span class="fl">1.0</span> <span class="op">/</span> beta_y)<span class="op">*</span> np.array([[beta_y, <span class="fl">0.0</span>], [alpha_y, <span class="fl">1.0</span>]])</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.apply_along_axis(<span class="kw">lambda</span> row: np.matmul(V, row), <span class="dv">1</span>, X)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Create and track bunches</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>sims <span class="op">=</span> []</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> intensity <span class="kw">in</span> intensities:</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    bunch <span class="op">=</span> Bunch(intensity, bunch_length)</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>    bunch.fill(np.copy(X))</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>    sim <span class="op">=</span> Simulation(bunch, distance, step_size, grid_size, meas_every<span class="op">=</span>meas_every, samples<span class="op">=</span>samples)</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>    sim.run()</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>    sims.append(sim)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-60" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>bunch_positions <span class="op">=</span> sims[<span class="dv">0</span>].history.moment_positions</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>env_positions <span class="op">=</span> np.linspace(<span class="dv">0</span>, distance, <span class="dv">400</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>rms_sizes_lists <span class="op">=</span> {<span class="st">'bunch'</span>:[], <span class="st">'env'</span>:[]}</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sim <span class="kw">in</span> sims:</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    rms_sizes_lists[<span class="st">'bunch'</span>].append(np.sqrt(sim.history.moments[:, [<span class="dv">0</span>, <span class="dv">7</span>]]))</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    rms_sizes_lists[<span class="st">'env'</span>].append(track_env(X, env_positions, sim.bunch.perveance)[:, [<span class="dv">0</span>, <span class="dv">2</span>]])</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> pplt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="fl">7.25</span>, <span class="fl">2.75</span>), spany<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>alphas <span class="op">=</span> np.linspace(<span class="fl">0.4</span>, <span class="fl">1.0</span>, <span class="dv">4</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>cycle <span class="op">=</span> pplt.Cycle(pplt.Colormap(<span class="st">'blues'</span>, left<span class="op">=</span><span class="fl">0.3</span>))</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> cycle.by_key()[<span class="st">'color'</span>][::<span class="dv">3</span>]</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, rms_sizes_list <span class="kw">in</span> rms_sizes_lists.items():</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> rms_sizes, alpha, color <span class="kw">in</span> <span class="bu">zip</span>(rms_sizes_list, alphas, colors):</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axs):</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> key <span class="op">==</span> <span class="st">'env'</span>:</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>                ax.plot(env_positions, <span class="fl">1000.0</span> <span class="op">*</span> rms_sizes[:, i], c<span class="op">=</span>color, alpha<span class="op">=</span>alpha)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> key <span class="op">==</span> <span class="st">'bunch'</span>:</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>                ax.scatter(bunch_positions, <span class="fl">1000.0</span> <span class="op">*</span> rms_sizes[:, i], s<span class="op">=</span><span class="dv">8</span>, c<span class="op">=</span>color, zorder<span class="op">=</span><span class="dv">99</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> [Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], color<span class="op">=</span>color) <span class="cf">for</span> color <span class="kw">in</span> colors]</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].legend(lines, [<span class="ss">f'$I/I_0$ = </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>)], ncols<span class="op">=</span><span class="dv">1</span>, fontsize<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="st">'Horizontal'</span>)</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="st">'Vertical'</span>)</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>axs.<span class="bu">format</span>(xlim<span class="op">=</span>(<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">10.5</span>), ylabel<span class="op">=</span><span class="st">'RMS beam size [$mm$]'</span>, xlabel<span class="op">=</span><span class="st">'Position [m]'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This plot shows the horizontal and vertical beam size over time for each of the four chosen beam intensities. The solid lines are the result of integrating the envelope equations, while the dots are the result of the PIC calculation. Notice that the beam expands on its own due to the nonzero emittance and that the effect of space charge is to increase the expansion rate. It seems to be quite accurate over this distance, and the runtime is acceptable for my purposes. Here is the evolution of 10,000 randomly sampled macroparicles compared with the KV envelope.</p>
<div id="cell-62" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get coordinates</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>coords_list <span class="op">=</span> [sim.history.coords <span class="cf">for</span> sim <span class="kw">in</span> sims]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> sims[<span class="dv">0</span>].history.coord_positions</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>umax <span class="op">=</span> <span class="fl">1.25</span> <span class="op">*</span> <span class="bu">max</span>([np.<span class="bu">max</span>(np.<span class="bu">max</span>(coords, axis<span class="op">=</span><span class="dv">1</span>)[:, [<span class="dv">0</span>, <span class="dv">2</span>]]) <span class="cf">for</span> coords <span class="kw">in</span> coords_list])</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>umax <span class="op">=</span> umax <span class="op">*</span> <span class="fl">1000.0</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create figure</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> pplt.subplots(nrows<span class="op">=</span><span class="dv">2</span>, ncols<span class="op">=</span><span class="dv">2</span>, figwidth<span class="op">=</span><span class="fl">5.0</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>axs.<span class="bu">format</span>(</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    xspineloc<span class="op">=</span><span class="st">'bottom'</span>, yspineloc<span class="op">=</span><span class="st">'left'</span>,</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    xlim<span class="op">=</span>(<span class="op">-</span>umax, umax), ylim<span class="op">=</span>(<span class="op">-</span>umax, umax),</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    xlabel<span class="op">=</span><span class="st">'x [mm]'</span>, ylabel<span class="op">=</span><span class="st">'y [mm]'</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].legend([Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'red6'</span>)], [<span class="st">'KV envelope'</span>], frameon<span class="op">=</span><span class="va">False</span>, loc<span class="op">=</span>(<span class="fl">0.5</span>, <span class="fl">0.95</span>))</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axs):</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="ss">f'$I/I_0$ = </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span>, xy<span class="op">=</span>(<span class="fl">0.05</span>, <span class="fl">0.9</span>), xycoords<span class="op">=</span><span class="st">'axes fraction'</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>plt.close()</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Create lines</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> []</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> axs:</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    line, <span class="op">=</span> ax.plot([], [], ms<span class="op">=</span><span class="fl">1.25</span>, c<span class="op">=</span><span class="st">'black'</span>, marker<span class="op">=</span><span class="st">'.'</span>, lw<span class="op">=</span><span class="dv">0</span>, mew<span class="op">=</span><span class="dv">0</span>, fillstyle<span class="op">=</span><span class="st">'full'</span>)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    lines.append(line)</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update(t):</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ax, coords, line, rms_sizes_list <span class="kw">in</span> <span class="bu">zip</span>(axs, coords_list, lines, rms_sizes_lists[<span class="st">'env'</span>]):</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        line.set_data(<span class="fl">1000.0</span> <span class="op">*</span> coords[t, :, <span class="dv">0</span>], <span class="fl">1000.0</span> <span class="op">*</span> coords[t, :, <span class="dv">2</span>])</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>        rms_sizes_list <span class="op">=</span> rms_sizes_list[::<span class="dv">4</span>]</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> <span class="fl">1000.0</span> <span class="op">*</span> rms_sizes_list[t]</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        ax.patches <span class="op">=</span> []</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        ax.add_patch(Ellipse((<span class="fl">0.0</span>, <span class="fl">0.0</span>), <span class="fl">4.0</span> <span class="op">*</span> a, <span class="fl">4.0</span> <span class="op">*</span> b, color<span class="op">=</span><span class="st">'red6'</span>, fill<span class="op">=</span><span class="va">False</span>, zorder<span class="op">=</span><span class="dv">100</span>, lw<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_title(<span class="st">'s = </span><span class="sc">{:.2f}</span><span class="st"> m'</span>.<span class="bu">format</span>(positions[t]))</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>frames <span class="op">=</span> <span class="bu">len</span>(coords_list[<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>anim <span class="op">=</span> animation.FuncAnimation(fig, update, frames<span class="op">=</span>frames, interval<span class="op">=</span><span class="fl">1000.0</span> <span class="op">/</span> <span class="fl">20.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="./_output_anim.gif" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Fig. 11. Evolution of 10,000 macroparticles (black) and KV envelope (red) during free-expansion."><img src="./_output_anim.gif" class="img-fluid figure-img" style="width:70.0%" alt="Fig. 11. Evolution of 10,000 macroparticles (black) and KV envelope (red) during free-expansion."></a></p>
<figcaption>Fig. 11. Evolution of 10,000 macroparticles (black) and KV envelope (red) during free-expansion.</figcaption>
</figure>
</div>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This post implemented an electrostatic PIC solver in Python. I learned quite a bit from doing this and was happy to see my calculations agree with the theoretical benchmark. One extension of this code would be to consider the velocity-dependent force from magnetic fields. It would also be straightforward to extend the code to 3D. Finally, all the methods used here are applicable to gravitational simulations. Here are some helpful references:</p>
<ul>
<li><a href="https://people.nscl.msu.edu/~lund/uspas/sbp_2018/">USPAS course</a></li>
<li><a href="https://www.amazon.com/Computer-Simulation-Using-Particles-Hockney/dp/0852743920">Hockney &amp; Eastwood</a></li>
<li><a href="https://www.amazon.com/Plasma-Physics-via-Computer-Simulation/dp/0750310251">Birdsall &amp; Langdon</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/austin-hoover\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"loop":false,"openEffect":"zoom","selector":".lightbox","closeEffect":"zoom","descPosition":"bottom"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>