<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Austin Hoover">
<meta name="dcterms.date" content="2024-06-06">

<title>Accelerated Inquiry - Maximum-entropy phase space tomography using normalizing flows (part 1)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-DLC4C8LZFB"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-DLC4C8LZFB', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Accelerated Inquiry</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about/index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../archive.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#indirectly-measuring-position-momentum-distributions" id="toc-indirectly-measuring-position-momentum-distributions" class="nav-link active" data-scroll-target="#indirectly-measuring-position-momentum-distributions">Indirectly measuring position-momentum distributions</a></li>
  <li><a href="#entropy-maximization-for-inverse-problems" id="toc-entropy-maximization-for-inverse-problems" class="nav-link" data-scroll-target="#entropy-maximization-for-inverse-problems">Entropy maximization for inverse problems</a></li>
  <li><a href="#maximum-entropy-algorithms" id="toc-maximum-entropy-algorithms" class="nav-link" data-scroll-target="#maximum-entropy-algorithms">Maximum-entropy algorithms</a>
  <ul>
  <li><a href="#ment" id="toc-ment" class="nav-link" data-scroll-target="#ment">MENT</a></li>
  <li><a href="#ment-flow" id="toc-ment-flow" class="nav-link" data-scroll-target="#ment-flow">MENT-Flow</a></li>
  </ul></li>
  <li><a href="#next-steps" id="toc-next-steps" class="nav-link" data-scroll-target="#next-steps">Next steps</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Maximum-entropy phase space tomography using normalizing flows (part 1)</h1>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Austin Hoover </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 6, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Phase space tomography is a technique to reconstruct a position-momentum distribution from its projections. Entropy maximization is a mathematically rigorous way to incorporate prior information in the reconstruction, providing strong regularization when measurements are sparse. Entropy maximization is challenging when the phase space is high-dimensional. In a preprint titled <em>High-dimensional phase space tomography using normalizing flows</em> [<a href="https://arxiv.org/abs/2406.00236">arxiv</a>], we explored the use of generative models, specifically <em>normalizing flows</em>, for maximum-entropy phase space tomography.</p>
<p>This post provides some background on the method in the paper. In the next post, Iâ€™ll describe some numerical experiments we used to test the method and an experimental reconstruction of a 4D phase space distribution of an intense beam in the SNS.</p>
<section id="indirectly-measuring-position-momentum-distributions" class="level2">
<h2 class="anchored" data-anchor-id="indirectly-measuring-position-momentum-distributions">Indirectly measuring position-momentum distributions</h2>
<p>To model the behavior of a charged particle beam, we need to know how its particles are distributed in position-momentum space, or <em>phase space</em>. There are six phase space variables: three position coordinates (<span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(z\)</span>) and three momentum coordinates (<span class="math inline">\(x'\)</span>, <span class="math inline">\(y'\)</span>, <span class="math inline">\(z'\)</span>), which we wrap into a single vector <span class="math inline">\(\mathbf{x} = [x, x', y, y', z, z']^T\)</span>. Since we canâ€™t measure individual particles, we describe the beam using a probability density function <span class="math inline">\(\rho(\mathbf{x})\)</span>, where</p>
<p><span id="eq-rho-norm"><span class="math display">\[
\int \rho(\mathbf{x}) d\mathbf{x} = 1.
\tag{1}\]</span></span></p>
<p>Measuring the phase space distribution is a major focus in accelerator physics. In a <a href="../2023-05-28_btf">previous post</a>, I described our efforts to measure the distribution directly. Here, Iâ€™ll describe efforts to reconstruct the distribution from partial information. Iâ€™ll assume we can only measure projections of the distribution onto position space. For example, we can measure the 1D distribution <span class="math inline">\(\rho(x)\)</span> by sweeping a conducting wire across the beam and measuring the secondary electrons emitted at each position.</p>
<p>The 1D distribution <span class="math inline">\(\rho(x)\)</span> is really an integral over the hidden momentum coordinates:</p>
<p><span id="eq-integral"><span class="math display">\[
\rho(x) = \int \rho(x, x') dx'.
\tag{2}\]</span></span></p>
<p>If we could rotate the phase space coordinates, we would obtain 1D projections along different angles in the 2D phase space. This is the same problem faced in medical CT, where the detector rotates instead of the object of interest. Thus, if we could rotate the phase space coordinates, we could apply standard CT algorithms to reconstruct the 2D phase space distribution from 1D measurements.</p>
<p>Imagine the beam was placed in a harmonic potential well. A beautiful insight from classical mechanics is that while particles in a harmonic potential perform sinusoidal oscillations in position space, they trace circles in phase space. In other words, they rotate. Thus, measuring <span class="math inline">\(\rho(x)\)</span> at different times would be equivalent to measuring the projection of <span class="math inline">\(\rho(x, x')\)</span> along different angles in phase space. The electromagnetic focusing fields in an accelerator <em>do not</em> create a simple harmonic potential. But after some approximations, we can often decouple the motion in the three planes and write</p>
<p><span id="eq-linear"><span class="math display">\[
\begin{bmatrix}
  x(t) \\ x'(t)
\end{bmatrix}
=
\mathbf{M}
\begin{bmatrix}
  x(0) \\ x'(0)
\end{bmatrix},
\tag{3}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{M}\)</span> is a symplectic matrix. And we can factor <span class="math inline">\(\mathbf{M}\)</span> into three components:</p>
<p><span id="eq-factored-matrix"><span class="math display">\[
\mathbf{M} =
\begin{bmatrix}
    \sqrt{\beta (t)} &amp; 0 \\
    -\frac{\alpha (t)}{\sqrt{\beta (t)}} &amp; \frac{1}{\sqrt{\beta (t)}}
\end{bmatrix}
\begin{bmatrix}
    \cos{(\phi t)} &amp; \sin{(\phi t)} \\ -\sin{(\phi t)} &amp; \cos{(\phi t)}
\end{bmatrix}
\begin{bmatrix}
    \sqrt{\beta (0)} &amp; 0 \\
    -\frac{\alpha (0)}{\sqrt{\beta (0)}} &amp; \frac{1}{\sqrt{\beta (0)}}
\end{bmatrix}
\tag{4}\]</span></span></p>
<p>The first and last matrices apply a scaling and shearing transformation, while the middle matrix applies a rotation in phase space. (See <a href="../2021-01-21_parametric_oscillators">this post</a>.) The rotation is the only part relevant to tomography, and we can account for the shearing and scaling so that our measurements still correspond to projections along different angles in phase space. We could measure the beam at different times by placing wire scanners at different positions along the accelerator lattice. Or we could measure the beam at one position and vary the upstream optics; both methods vary the transfer matrix, which is all that matters. Thus, by measuring the spatial density at different locations along the accelerator lattice or under different focusing optics, we can use any CT algorithm to reconstruct the phase space distribution at any point upstream of the measurements.</p>
<p>The problem becomes <em>much</em> more difficult when considering 6D phase space tomography from arbitrary phase space transformations. One difficulty is that we have to search the space of 6D distribution functions. In 2D, we can course-grain the distribution and search the space of images, but this does not scale well to 6D. A <span class="math inline">\(50 \times 50 \times 50 \times 50 \times 50 \times 50\)</span> grid already has <span class="math inline">\(15 \times 10^9\)</span> cells! The storage requirements for many conventional tomography algorithms are even worse because they have to store a matrix connecting the distribution to its projections. For this reason, even 4D tomography rules out the use of most conventional algorithms.</p>
</section>
<section id="entropy-maximization-for-inverse-problems" class="level2">
<h2 class="anchored" data-anchor-id="entropy-maximization-for-inverse-problems">Entropy maximization for inverse problems</h2>
<p>Another difficulty is that we canâ€™t just take any measurement we wish. In medical CT, reconstructions proceed from hundreds of measurements at optimally chosen projection angles, but in accelerators, we could be limited to tens of measurements, even as few as three or four in some cases. Furthermore, the measurements may be suboptimal. In medical CT, we know that we should space the projection angles evenly over 180 degrees and can easily do this by rotating our X-ray detector. Accelerator constraints disallow many optics settings, so we canâ€™t alsways access the full 180 degree range with equally spaced angles. And in 6D tomography, itâ€™s not entirely clear how to determine the optimal set of transformations. All this to say, reconstructions sometimes proceed without much data, resulting in an ill-posed inverse problem. There could be various distributions consistent with the same measurements. This problem is already important in 2D and could be exponentially worse in 4D or 6D. How should we proceed if we must select a <em>single</em> distribution from the feasible set?</p>
<p>It seems that all we can do is rank each feasible distribution and select the distribution with the highest ranking. Equivalently, we can maximize a functional <span class="math inline">\(H[\rho(\mathbf{x})]\)</span>, subject to the measurement constraints. At this point, weâ€™ve assumed nothing about <span class="math inline">\(H\)</span>. There might not be a universal functional that applies in all situations, but if there is such a functional, it should give correct results in simple cases. It turns out that a universal <span class="math inline">\(H\)</span> is pinned down by four requirements <span class="citation" data-cites="Presse_2013">&nbsp;[<a href="#ref-Presse_2013" role="doc-biblioref">1</a>]</span>:</p>
<ol type="1">
<li><em>Uniqueness</em>: The maximum of <span class="math inline">\(H\)</span> should be unique.</li>
<li><em>Invariance</em>: The maximum of <span class="math inline">\(H\)</span> should not depend on the choice of coordinates.</li>
<li><em>Subset independence</em>: Updating the distribution in one domain should not require updating the distribution in a separate domain.</li>
<li><em>System independence</em>: If we only know the marginal distributions <span class="math inline">\(\rho(\mathbf{y})\)</span> and <span class="math inline">\(\rho(\mathbf{z})\)</span> and have no prior assumption of dependence between <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{z}\)</span>, then the reconstruction should not contain any such dependence: <span class="math inline">\(\rho(\mathbf{y}, \mathbf{z}) = \rho(\mathbf{y})\rho(\mathbf{z})\)</span>.</li>
</ol>
<p>We end up with the relative entropy:</p>
<p><span id="eq-entropy"><span class="math display">\[
H[\rho(\mathbf{x}), \rho_*(\mathbf{x})] =
-\int \rho(\mathbf{x}) \log\left(\frac{\rho(\mathbf{x})}{\rho_*(\mathbf{x})}\right) d\mathbf{x}
\tag{5}\]</span></span></p>
<p>Here, <span class="math inline">\(\rho_*(\mathbf{x})\)</span> is a <em>prior</em> enoding our knowledge before seeing any data. The relative entropy has a maximum at zero when <span class="math inline">\(\rho(\mathbf{x}) = \rho_*(\mathbf{x})\)</span>, so if there is no data, entropy maximization (ME) returns the prior. ME tells us what <em>not</em> to do: it tells us not to change our minds unless <em>forced</em> by the data, on pain of logical inconsistency.</p>
<p>ME is a general principle, not confined to tomography, statistical physics, or any specific problem. It sits on a firm mathematical foundation. The only arguments <em>against</em> ME are the following:</p>
<ol type="1">
<li>We have plenty of data; all algorithms give the same answer.</li>
<li>Itâ€™s too difficult to maximize entropy.</li>
</ol>
<p>Iâ€™ve argued above that particle accelerator measurements do not always tightly constrain the phase space distribution. That leaves the second consideration. Indeed, maximizing entropy is challenging, as the entropy is a highly nonlinear function of the probability density.</p>
</section>
<section id="maximum-entropy-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="maximum-entropy-algorithms">Maximum-entropy algorithms</h2>
<p>Iâ€™ll now describe three approaches to our constrained optimization problem. Letâ€™s begin by writing the measurement constraints in their most general form. Let <span class="math inline">\(\mathbf{x} \in \mathbb{R}^n\)</span> represent the phase space coordinates of a particle in the beam. On each measurement, particles travel through the accelerator to a measurement device. This transformation is symplectic, so we represent the <span class="math inline">\(k\)</span>th transport by a symplectic map <span class="math inline">\(\mathcal{M}_k: \mathcal{R}^n \rightarrow \mathcal{R}^n\)</span>. Denote the transformed coordinates as</p>
<p><span id="eq-forward"><span class="math display">\[
\mathbf{u}_k = \mathcal{M}_k(\mathbf{x}).
\tag{6}\]</span></span></p>
<p>Once we have the transformed coordinates, we measure the particle density on a lower dimensional plane, or <em>projection axis</em>, <span class="math inline">\(\mathbf{u}_{k_\parallel} \in \mathbb{R}^m\)</span>. To compute the projection in the particle picture, we keep these <span class="math inline">\(m\)</span> dimensions and discard the rest. Or if we work with the phase space density, we can write the projection as an integral over an orthogonal <em>integration axis</em> <span class="math inline">\(\mathbf{u}_{k_\perp} \in \mathbb{R}^{n - m}\)</span> (the unmeasured dimensions). In the following equation, <span class="math inline">\(g(\mathbf{u}_{k_\parallel})\)</span> is the measured projected density.</p>
<p><span id="eq-projections"><span class="math display">\[
\begin{aligned}
    g(\mathbf{u}_{k_\parallel}) &amp;- \int{\rho \left( \mathbf{x}(\mathbf{u}_k) \right) d\mathbf{u}_{k_\perp}} = 0\\
    g(\mathbf{u}_{k_\parallel}) &amp;- \int{\rho \left( \mathcal{M}_k^{-1}(\mathbf{u}_k )\right) d\mathbf{u}_{k_\perp}} = 0
\end{aligned}
\tag{7}\]</span></span></p>
<p>Our task is to maximize the entropy in <a href="#eq-entropy" class="quarto-xref">Equation&nbsp;5</a>, subject to the constraints in <a href="#eq-projections" class="quarto-xref">Equation&nbsp;7</a>.</p>
<section id="ment" class="level3">
<h3 class="anchored" data-anchor-id="ment">MENT</h3>
<p>Although the problem seems hopeless at first, we can make some progress using the method of Lagrange multipliers <a href="https://en.wikipedia.org/wiki/Lagrange_multiplier">Lagrange multipliers</a>. Weâ€™ll introduce a new function:</p>
<p><span id="eq-functional"><span class="math display">\[
\Psi
=
H[\rho(\mathbf{x}), \rho_*(\mathbf{x})]
+
\sum_{k}^{} {
\int
    \lambda_{k}(\mathbf{u}_{k_\parallel})
    \left(
        g_k(\mathbf{u}_{k_\parallel}) -
        \int \rho \left( \mathcal{M}_k^{-1}(\mathbf{u}_k) \right)
        d\mathbf{u}_{k_\perp}
    \right)
    d\mathbf{u}_{k_\parallel}
}
\tag{8}\]</span></span></p>
<p>Weâ€™ve assigned a Lagrange multiplier to every point along each measurement axis. Since the measurements are continuous, the sum over Lagrange multipliers becomes an integral over Lagrange functions. The sum over <span class="math inline">\(k\)</span> is just adding up all the measurements. To find the constrained maximum of <span class="math inline">\(H\)</span>, we need to find the stationary point of <span class="math inline">\(\Psi\)</span> with respect to the distribution <span class="math inline">\(\rho(\mathbf{x})\)</span> and the Lagrange functions <span class="math inline">\(\lambda_k(\mathbf{u}_{k_\parallel})\)</span>.</p>
<p><span class="math display">\[
\frac{\delta \Psi}{\delta \rho} = 0, \frac{\delta \Psi}{\delta \lambda_k} = 0
\]</span></p>
<p>I usually just treat functional derivatives as regular derivatives, and things tend to work out. For example, the derivative of the entropy is</p>
<p><span id="eq-deriv-entropy"><span class="math display">\[
\frac{\delta}{\delta \rho(\mathbf{x})} H[\rho(\mathbf{x}), \rho_*(\mathbf{x})]
=
-1 - \log\frac{\rho(\mathbf{x})}{\rho_*(\mathbf{x})}
\tag{9}\]</span></span></p>
<p>We can do a similar thing for the constraint equations. (Setting the derivative with respect to the Lagrange functions to zero returns the constraint equations). We end up with</p>
<p><span id="eq-ment-solution"><span class="math display">\[
\begin{aligned}
    \rho(\mathbf{x})
    &amp;=
    \rho_*(\mathbf{x})
    \prod_{k} \exp{ \left( \lambda_k(\mathbf{u}_{k_\parallel} (\mathbf{x})) \right) }
\end{aligned}
\tag{10}\]</span></span></p>
<p><a href="#eq-ment-solution" class="quarto-xref">Equation&nbsp;10</a> parameterizes the maximum entropy distribution. We can substitute <a href="#eq-ment-solution" class="quarto-xref">Equation&nbsp;10</a> into <a href="#eq-projections" class="quarto-xref">Equation&nbsp;7</a> to generate a set of highly nonlinear coupled integral equations and solve for the Lagrange functions. If successful, we would find an <em>exact</em> solution. No constrained optimization needed!</p>
<p>MENT is an algorithm to optimize the Lagrange functions directly. I wonâ€™t describe the algorithm here. For now, I note that itâ€™s unclear whether MENT can be efficiently implemented in 6D phase space. Thus, we wanted to know if another algorithm could find approximate maximum-entropy solutions in 6D phase space, even if we have to sacrifice some of MENTâ€™s nice properties.</p>
</section>
<section id="ment-flow" class="level3">
<h3 class="anchored" data-anchor-id="ment-flow">MENT-Flow</h3>
<p>We can leverage generative models to extend maximum entropy tomography to 6D phase space. Generative models represent a distribution <span class="math inline">\(\rho(\mathbf{x})\)</span> via transformed samples:</p>
<p><span class="math display">\[
\mathbf{x} = \mathcal{F}(\mathbf{z}),
\]</span></p>
<p>where <span class="math inline">\(\mathbf{z}\)</span> is a random variable from a <em>base distribution</em> <span class="math inline">\(\rho_0(\mathbf{z})\)</span> and <span class="math inline">\(\mathcal{F}: \mathbb{R}^{n'} \rightarrow \mathbb{R}^n\)</span> is any transformation. Weâ€™ll call <span class="math inline">\(\mathbf{z}\)</span> the normalized coordinates. If the base distribution is easy to sample from, generating iid samples from the true distribution is trivial: sample <span class="math inline">\(\mathbf{z}\)</span> and unnnormalize. A neural network can represent almost any transformation with a finite number of parameters, so we can model almost any distribution by letting a neural network represent <span class="math inline">\(\mathcal{F}\)</span>.</p>
<p>Based on this approach, Roussel et al. <span class="citation" data-cites="Roussel_2023">&nbsp;[<a href="#ref-Roussel_2023" role="doc-biblioref">2</a>]</span> proposed a clever tomography algorithm called *Generative Phase Space Reconstruction (GPSR). Generative models are typically trained on data samples, but they donâ€™t have to be.GPSR trains a generative model on projected densities. It samples particles from the base distribution, unnormalizes the coordinates through a neural network transformation, propagates the particles to each measurement device, and computes the projected density on the measurement planes. Then it compares the simulated projection to the measured projections, updating the network parameters until they match.</p>
<p>The trick is implementing the beam dynamics simulation <span class="math inline">\(\mathcal{M}_k\)</span>. This simulation must be differentiable to backpropagate the loss through the network. Many accelerator components can be modeled in differentiable libraries such as pytorch. A second trick is in implementing the projected density estimation. Although histogram binning isnâ€™t differentiable, kernel density estimation (KDE) is. And KDE is efficient enough for 1D and 2D data. Armed with a differentiable loss function, GPSR should be able to fit almost any <span class="math inline">\(n\)</span>-dimensional distribution to 1D or 2D measurements.</p>
<p>We used a variant of GPSR to maximize the distributionâ€™s entropy in addition to fitting the projection data. We followed Loaiza-Ganem, Gao, and Cunningham <span class="citation" data-cites="Loaiza_2016">&nbsp;[<a href="#ref-Loaiza_2016" role="doc-biblioref">3</a>]</span>, who worked on entropy maximization for a different problem with moment constraints rather than tomographic constraints. They proposed to use <em>normalizing flows</em> to maximize the entropy. A normalizing flow is a special type of generative model. Instead of just any unnormalizing transformation <span class="math inline">\(\mathcal{F}\)</span>, we use a <em>diffeomorphism</em> â€” a smooth, invertible transformation. Think of a sheet of fabric that can stretch and compress but cannot tear. If we use such a transformation, we can track the change in probability density from the base distribution:</p>
<p><span class="math display">\[
\log\rho(\mathbf{x}) = \log\rho_0(\mathbf{z}) - \left| \det \frac{d\mathbf{x}}{d\mathbf{z}} \right|
\]</span></p>
<p>The last term, called the <em>Jacobian matrix</em> accounts for volume change and ensures the probabilty density remains normalized.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> For <span class="math inline">\(\mathbf{x} = [x_1, \dots, x_n]^T\)</span> and <span class="math inline">\(\mathbf{z} = [z_1, \dots, z_n]^T\)</span></p>
<p><span id="eq-jacobian"><span class="math display">\[
\frac{d\mathbf{x}}{d\mathbf{z}} =
\begin{bmatrix}
    \frac{dx_1}{dz_1} &amp; \dots &amp; \frac{dx_1}{dz_n} \\
    \vdots &amp; \ddots &amp; \vdots \\
    \frac{dx_n}{dz_1} &amp; \dots &amp; \frac{dx_n}{dz_n} \\
\end{bmatrix}
\tag{11}\]</span></span></p>
<p>If we could compute <a href="#eq-jacobian" class="quarto-xref">Equation&nbsp;11</a>, we could easily estimate the expected value of any function <span class="math inline">\(Q(\mathbf{x})\)</span> under <span class="math inline">\(\rho(\mathbf{x})\)</span>:</p>
<p><span id="eq-expected-value"><span class="math display">\[
\begin{aligned}
\mathbb{E}_{\rho(\mathbf{x})} \left[ Q(\mathbf{x}) \right]
= \int Q(\mathbf{x}) \rho(\mathbf{x}) d\mathbf{x}
\approx \frac{1}{N} \sum_{i=1}^{N} Q(\mathbf{x}_i)
\end{aligned}
\tag{12}\]</span></span></p>
<p>Here, <span class="math inline">\(\left\{ \mathbf{x}_i \right\}\)</span> are samples drawn from <span class="math inline">\(\rho(\mathbf{x})\)</span>. Crucially, the entropy is an expected value!</p>
<p><span id="eq-entropy-est"><span class="math display">\[
\begin{aligned}
-H[\rho(\mathbf{x}), \rho_*(\mathbf{x})]
&amp;= \int \rho(\mathbf{x}) \log\left(\frac{\rho(\mathbf{x})}{\rho_*(\mathbf{x})}\right) d\mathbf{x} \\
-H[\rho(\mathbf{x}), \rho_*(\mathbf{x})]
&amp;= \mathbb{E}_{\rho(\mathbf{x})} \left[ \log\rho(\mathbf{x}) - \log\rho_*(\mathbf{x}) \right] \\
-H[\rho(\mathbf{x}), \rho_*(\mathbf{x})]
&amp;\approx \frac{1}{N} \sum_{i=1}^{N} \left( \log\rho(\mathbf{x}_i) - \log\rho_*(\mathbf{x}_i) \right)
\end{aligned}
\tag{13}\]</span></span></p>
<p>So, we can use normalizing flows to estimate the relative entropy. We can also maximize the entropy because the estimate in <a href="#eq-entropy-est" class="quarto-xref">Equation&nbsp;13</a> is differentiable. To incorporate constraints, we use the GPSR framework described above. Combining these two ingredients gives us an approximate maximum entropy phase space tomography algorithm. We ended up using a rather simple penalty method for the constrained optimization. The penalty method minimizes the following loss function:</p>
<p><span id="eq-loss"><span class="math display">\[
L[
    \rho (\mathbf{x}),
    \rho_*(\mathbf{x}),
    \{ {g}_k(\mathbf{u}_{k_\parallel}) \}
]
=
- H[\rho(\mathbf{x}), \rho_*(\mathbf{x})]
+
\mu \sum_{k} {
    D[
        {g}_k(\mathbf{u}_{k_\parallel}),
        \tilde{g}_k(\mathbf{u}_{k_\parallel})
    ]
}
\tag{14}\]</span></span></p>
<p>We minimize this loss function for a fixed penalty parameter <span class="math inline">\(\mu\)</span>, starting from <span class="math inline">\(\mu = 0\)</span> (returning the prior). Then we increase <span class="math inline">\(mu\)</span> and rerun the optimization, starting from the last solution.</p>
<div id="fig-diagram" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="figures/fig_diagram.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" data-glightbox="description: .lightbox-desc-1"><img src="figures/fig_diagram.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: GPSR with a normalizing flow generator. The flow uses a smooth, invertible transformation to unnormalize the <span class="math inline">\(n\)</span>-dimensional Gaussian base distribution, producing a phase space distribution <span class="math inline">\(\rho(\mathbf{x})\)</span>. The phase space coordinates are propagated through a series of symplectic transformatiosn <span class="math inline">\(\mathbf{u}_k = \mathcal{M}_k(\mathbf{x})\)</span>, projected onto the <span class="math inline">\(m\)</span>-dimensional measurement axes <span class="math inline">\(\mathbf{u}_{k_\parallel}\)</span>, and binned to compare to the measurements. Each step is differentiable, enabling gradient-based optimization of the flow parameters.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="next-steps" class="level2">
<h2 class="anchored" data-anchor-id="next-steps">Next steps</h2>
<p>The text above sets up the maximum-entropy phase space tomography problem and suggests an approximate but scalable reconstruction model based on existing work. The primary questions we wanted to answer in this study were:</p>
<ol type="1">
<li>Is the flow-based entropy estimate in <a href="#eq-entropy-est" class="quarto-xref">Equation&nbsp;13</a> sufficient? How can we judge its accuracy?</li>
<li>Are normalizing flows fast and flexible enough to model complex 6D phase space distributions to projection data? Itâ€™s not obvious. Flow-based models are typically quite large and slow to train, and we require large batch sizes for GPSR.</li>
</ol>
<p>In the next post, Iâ€™ll describe the model architecture and the numerical experiments we used to answer these questions. Iâ€™ll also describe an experiment we performed at the SNS to reconstruct the 4D phase space distribution of an intense ion beam from 1D profile measurements using MENT-Flow.</p>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">Figure&nbsp;1: GPSR with a normalizing flow generator. The flow uses a smooth, invertible transformation to unnormalize the <span class="math inline">\(n\)</span>-dimensional Gaussian base distribution, producing a phase space distribution <span class="math inline">\(\rho(\mathbf{x})\)</span>. The phase space coordinates are propagated through a series of symplectic transformatiosn <span class="math inline">\(\mathbf{u}_k = \mathcal{M}_k(\mathbf{x})\)</span>, projected onto the <span class="math inline">\(m\)</span>-dimensional measurement axes <span class="math inline">\(\mathbf{u}_{k_\parallel}\)</span>, and binned to compare to the measurements. Each step is differentiable, enabling gradient-based optimization of the flow parameters.</span>
</div>

</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-Presse_2013" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">S. PressÃ©, K. Ghosh, J. Lee, and K. A. Dill, <em><a href="https://doi.org/10.1103/RevModPhys.85.1115">Principles of Maximum Entropy and Maximum Caliber in Statistical Physics</a></em>, Rev. Mod. Phys. <strong>85</strong>, 1115 (2013).</div>
</div>
<div id="ref-Roussel_2023" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">R. Roussel, A. Edelen, C. Mayes, D. Ratner, J. P. Gonzalez-Aguilera, S. Kim, E. Wisniewski, and J. Power, <em>Phase Space Reconstruction from Accelerator Beam Measurements Using Neural Networks and Differentiable Simulations</em>, Physical Review Letters <strong>130</strong>, 145001 (2023).</div>
</div>
<div id="ref-Loaiza_2016" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">G. Loaiza-Ganem, Y. Gao, and J. P. Cunningham, <em>Maximum Entropy Flow Networks</em>, in <em>International Conference on Learning Representations</em> (2016).</div>
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>For a symplectic transformation, the Jacobian determinant is zero (the phase space density behaves as incompressible fluid).<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/austin-hoover\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="austin-hoover/blog" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"selector":".lightbox","descPosition":"bottom","loop":false,"openEffect":"zoom","closeEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>